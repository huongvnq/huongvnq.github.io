{"meta":{"title":"Meditation Coding","subtitle":"","description":"","author":"HuongVNQ","url":"https://huongvnq.github.io","root":"/"},"pages":[{"title":"About","date":"2021-07-18T02:39:35.000Z","updated":"2021-07-21T03:49:02.252Z","comments":false,"path":"about/index.html","permalink":"https://huongvnq.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-07-18T01:49:17.000Z","updated":"2021-07-18T02:36:42.989Z","comments":true,"path":"categories/index.html","permalink":"https://huongvnq.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-07-18T02:02:02.000Z","updated":"2021-07-18T08:59:38.632Z","comments":true,"path":"tags/index.html","permalink":"https://huongvnq.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Routing Trong Magento2","slug":"routing-in-magento2","date":"2021-07-20T05:05:37.000Z","updated":"2021-07-21T03:43:28.857Z","comments":false,"path":"2021/07/20/routing-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/07/20/routing-in-magento2/","excerpt":"","text":"1.Lời mở đầu Routing là một trong những phần rất quan trọng trong luồng hoạt động của Magento2. Routing sẽ chịu trách nhiệm xử lý URL request, từ URL sẽ chỉ ra module nào chịu trách nhiệm xử lý request và thực thi controller action. Trong bài viết này, chúng ta sẽ cùng đi tìm hiểu cách mà router sẽ “match” với controller action như thế nào. Sau đó sẽ tìm hiểu cách tạo một custom router. Hãy cùng đi vào nội dung của bài viết thôi nào :smile: 2.Magento2 Request Flow Trong Magento2, một request URL sẽ như thế này1http://example.com/index.php/front_name/controller/action Trong url trên, front_name sẽ được dùng để chỉ định module. Router sẽ định nghĩa cái tên này cho mỗi module trong file routes.xml Khi bạn tạo một request trong Magento2, Magento2 sẽ xử lý theo luồng như sau FrontController sẽ được gọi đến trong class Http để điều hướng request.Chúng ta hãy cùng xem File vendor/magento/framework/App/FrontController.php12345678910111213141516171819202122232425262728293031323334public function dispatch(RequestInterface $request)&#123; \\Magento\\Framework\\Profiler::start(&#x27;routers_match&#x27;); $routingCycleCounter = 0; $result = null; while (!$request-&gt;isDispatched() &amp;&amp; $routingCycleCounter++ &lt; 100) &#123; /** @var \\Magento\\Framework\\App\\RouterInterface $router */ foreach ($this-&gt;_routerList as $router) &#123; try &#123; $actionInstance = $router-&gt;match($request); if ($actionInstance) &#123; $request-&gt;setDispatched(true); $this-&gt;response-&gt;setNoCacheHeaders(); if ($actionInstance instanceof \\Magento\\Framework\\App\\Action\\AbstractAction) &#123; $result = $actionInstance-&gt;dispatch($request); &#125; else &#123; $result = $actionInstance-&gt;execute(); &#125; break; &#125; &#125; catch (\\Magento\\Framework\\Exception\\NotFoundException $e) &#123; $request-&gt;initForward(); $request-&gt;setActionName(&#x27;noroute&#x27;); $request-&gt;setDispatched(false); break; &#125; &#125; &#125; \\Magento\\Framework\\Profiler::stop(&#x27;routers_match&#x27;); if ($routingCycleCounter &gt; 100) &#123; throw new \\LogicException(&#x27;Front controller reached 100 router match iterations&#x27;); &#125; return $result;&#125; Chúng ta có thể thấy ở hàm dispatch, router list sẽ được cho vào vòng lặp để tìm kiếm router nào sẽ match với request. Khi tìm ra controller action nào “match” với request, action đó sẽ được gọi và thực thi. 3.Tạo một custom route trong area Frontend Trước khi đi vào tạo một route, chúng ta hãy tạo một module, tham khảo bài viết Create A New Module In Magento2 Ở đây mình tạo Module là Learning_Routing Để đăng kí một frontend route, chúng ta phải tạo file routes.xmlFile app/code/Learning/Routing/etc/frontend/routes.xml 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;!--Use router &#x27;standard&#x27; for frontend route--&gt; &lt;router id=&quot;standard&quot;&gt; &lt;!--Define a custom route with id and frontName--&gt; &lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt; &lt;!--The module which this route match to--&gt; &lt;module name=&quot;Learning_Routing&quot;/&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Thật đơn giản để đăng kí một route. Ở đây ta phải sử dụng standard router cho area Frontend. Route này sẽ có một route con định nghĩa module cho nó và 2 attribute: Attribute id là một chuỗi unique định danh một route. Chúng ta cũng sẽ sử dụng chuỗi này để khai báo layout cho action của module. Attribute frontName cũng là một chuỗi unique, chuỗi này được chỉ định trong url. Ví dụ nếu bạn khai báo một route như sau 1&lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt; Thì Url sẽ là 1http://example.com/index.php/helloworld/controller/action Layout cho action này sẽ là 1helloworld_controller_action.xml Và chúng ta phải tạo controller action ở trong thư mục 1&#123;namespace&#125;/&#123;module&#125;/Controller/&#123;Controller&#125;/&#123;Action&#125;.php 4. Tạo một custom route trong area Admin (Admin Route) Route này tương tự như route cho Frontend chỉ khác là chúng ta sẽ khai báo nó trong thư mục adminhtml và với router id là admin File app/code/Learning/Routing/etc/adminhtml/routes.xml 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;!--Use router &#x27;admin&#x27; for admin route --&gt; &lt;router id=&quot;admin&quot;&gt; &lt;!--Define a custom route with id and frontName --&gt; &lt;route id=&quot;learning_routing&quot; frontName=&quot;learning_routing&quot;&gt; &lt;!--The module which this route match to--&gt; &lt;module name=&quot;Learning_Routing&quot;/&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Một URL của một admin page sẽ có cấu trúc tương tự như đối với frontend page, tuy nhiên admin_area sẽ được thêm vào ở đằng trước frontName để chỉ định đây là một route của area Admin.Ví dụ url của một admin csm page 1http://example.com/index.php/admin/learning_routing/controller/action Controller Action cho admin page cũng sẽ được thêm vào bên trong thư mục Controller/Adminhtml 1&#123;namespace&#125;/&#123;module&#125;/Controller/Adminhtml/&#123;Controller&#125;/&#123;Action&#125;.php 5. Cách sử dụng route để ghì đè controller của core Như chúng ta đã thấy ở những phần bên trên, mỗi route sẽ có một id để định danh. Vậy điều gì sẽ xảy ra nếu chúng ta định nghĩa 2 route với cùng một id? Câu trả lời là action controller sẽ tìm thấy ở cả 2 modules. Và chúng ta phải sử dụng attribute before/after để config thứ tự module, chỉ định module nào sẽ được tìm thấy trước. Ví dụ, nếu mà chúng ta muốn ghi đè controller customer/account/login chúng ta sẽ định route trong route.xml như thế này:1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;!--Use router &#x27;standard&#x27; for frontend route--&gt; &lt;router id=&quot;standard&quot;&gt; &lt;!--Define a custom route with id and frontName--&gt; &lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt; &lt;!--The module which this route match to--&gt; &lt;module name=&quot;Learning_Routing&quot;/&gt; &lt;/route&gt; &lt;route id=&quot;customer&quot;&gt; &lt;module name=&quot;Learning_Routing&quot; before=&quot;Magento_Customer&quot; /&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Sau đó định nghĩa một file controller :app/code/Learning/Routing/Controller/Account/Login.php Khi đó, FrontController sẽ tìm thấy action Login ở trong Module Learning_Routing trước, action này sẽ được chạy và action Login của Magento_Customer sẽ không được chạy nữa. Như vậy là chúng ta đã thực hiện ghi đè Controller thành công. 6. Tổng kết Route là một phần cơ bản mà chúng ta phải biết khi tìm hiểu về luồng hoạt động của Magento. Qua bài viết này mong các bạn sẽ nắm được cách hoạt động của một route và đặc biệt là các quy tắc đặt tên để Magento có thể nhận biết và xử lý. Cảm ơn các bạn đã đọc đến cuối bài viết và hẹn gặp lại các bạn trong các bài viết tiếp theo của serries Tìm hiểu về Magento. :kissing_heart: Nguồn tham khảo: https://www.mageplaza.com/magento-2-module-development/magento-2-routing.html","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Create A New Module In Magento2","slug":"create-a-new-module-in-magento2","date":"2021-07-18T03:55:23.000Z","updated":"2021-07-20T02:52:16.292Z","comments":false,"path":"2021/07/18/create-a-new-module-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/07/18/create-a-new-module-in-magento2/","excerpt":"","text":"1.Tổng quát Module là một đơn vị cấu trúc của Magento. Toàn bộ hệ thống sẽ được xây dựng dựa trên các Module. Thông thường, bước đầu tiên để custom core của mangeto cũng là tạo module. Để tạo một module, chúng ta phải thực hiện các bước sau: Tạo một thư mục module Tạo file etc/module.xml Tạo file registration.php Chạy script bin/magento setup:upgrade để install module mới Kiểm tra module được active hay chưa. chúng ta hãy cùng đi vào cụ thể từng bước nhé. 2. Tạo thư mục cho module Chúng ta có 2 nơi để tạo thư mục cho module. Đó là trong folder app/code và trong folder vendor. Tuỳ thuộc vào cách cài đặt Magento2, những module core của magento có thể được đặt trong các thư mục vendor/magento/magento-* (trường hợp dùng composer để install) hoặc app/code/Magento/ (trường hợp clone Github) Vậy chúng ta nên đặt module mới ở đâu? Nếu chúng ta build một module cho một project cụ thể, chúng ta sẽ tạo mới module ở trong thư mục app/code và commit lên repository của product trên Github. Nếu chúng ta xây dựng một extension để tái sử dụng, chúng ta sẽ dùng composer để tạo nó và chúng ta sẽ đặt module ở trong vendor/&lt;YOUR_VENDOR&gt;/module-something Tên của module trong magento2 sẽ bao gồm 2 phần: tên vendor và tên của chính module đó. Nói cách khác, module sẽ được nhóm lại thành 1 vendor do vậy khi đặt tên của module ta phải chỉ định cả tên vendor đó. Trong ví dụ này chúng ta sẽ tạo một vendor là Learning và một module là First Unit cd to folder root mkdir app/code/Learning mkdir app/code/Learning/FirstUnit 3. Tạo file etc/module.xml Trước tiên chúng ta phải đảm bảo rằng chúng ta có quyền để tạo file và folder trong folder root nhé. Nếu đã có quyền, chúng ta tạo một file etc/module.xml. Phải có file này thì module mới tồn tại được. File module.xml chứa các thông tin sau Module name Module version Dependencies Module name đã được định nghĩa bằng tên thư mục mà chúng ta vừa tạo. Trong Magento2, tất cả các class name phải tuân theo cấu trúc thư mục. Bởi vì chúng ta tạo thư mục là Learning/FirstUnit nên module name của chúng ta sẽ là Learning_FirstUnit. Tất cả các class thuộc module này sẽ là bắt đầu với Learning/FirstUnitVí dụ Learning\\FirstUnit\\Observer\\Test Tiếp theo đến Module version. Module version cho biết được phiên bản hiện tại của database schema và data, được sử dụng cho việc upgrade module. Ví dụ như giả định bạn muốn thay đổi cấu trúc bảng dữ liệu (database table schema) của module này. Làm thế nào để bạn đảm bảo rằng thay đổi này sẽ được áp dụng trên tất cả các phiên bản mã code đã được deploy rồi. Magento sẽ có các script install và upgrade cho mỗi module (Hoặc bạn tự tạo). Các file script này sẽ có các command để thay đổi database schema và data. Để theo dõi xem liệu đã thực thi phần lệnh trong script hay chưa, magento sẽ track dựa vào module version. Mỗi lần bạn thực thi thay đổi mới trong database, bạn sẽ phải thực thi với version mới của module và tăng version của module lên tương ứng trong file module.xml. Magento sẽ lưu phiên bản hiện tại của module trong database. Nếu giá trị trong database và trong file module.xml không khớp với nhau, nó sẽ thực thi upgrade code. Dependencies: Nếu một module phụ thuộc vào một module khác thì chúng ta phải khai báo trong file modules.xml danh sách các module mà module hiện tại của chúng ta đang phụ thuộc vào. Ví dụ, module này chúng ta tạo ra sẽ phụ thuộc vào module Magento_Catalog. Đầu tiên chúng ta tạo folder etc:mkdir app/code/Learning/FirstUnit/etc Tạo file module.xmll12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:Module/etc/module.xsd&quot;&gt; &lt;module name=&quot;Learning_FirstUnit&quot; setup_version=&quot;0.0.1&quot;&gt; &lt;sequence&gt; &lt;module name=&quot;Magento_Catalog&quot;/&gt; &lt;/sequence&gt; &lt;/module&gt;&lt;/config&gt; Trong file module mà chúng ta vừa tạo, chúng ta đã chỉ định: Module name: Learning_FirstUnit dựa trên folder mà chúng ta đã tạo. Versionn: 0.0.1 (Version khởi tạo của module) Dependency: Magento_Catalog. Chúng ta có thể có nhiều Dependency, khi ấy chúng ta hãy liệt kê bằng các thẻ &lt;module name=&quot;...&quot; /&gt; ở bên trong thẻ &lt;sequence&gt; 4. Tạo file registration.php Mỗi module sẽ phải có file này để đăng kí cho magento biết vị trí của module. Tiếp tục example, chúng ta sẽ tạo file app/code/Learning/FirstUnit/registration.php1234&lt;?php \\Magento\\Framework\\Component\\ComponentRegistrar::register(\\Magento\\Framework\\Component\\ComponentRegistrar::MODULE, &#x27;Learning_FirstUnit&#x27;,__DIR__); File registrationn.phpp sẽ giống nhau đối với tất cả các module, chỉ khác tên của module, ở đây của chúng ta là Learning_FirstUnit 5. Chạy command Tạo xong module chúng ta phải chạy command để active module, để thông báo cho magento biết về sự hiện diện của nó.1$ php bin/magento setup:upgrade Câu lệnh sẽ cho ra rất nhiều dòng input, hãy check xem một trong các dòng đó có Learning_FirstUnit hay không. 6 Check module is active Mặc dù chúng ta chưa add những logic code vào module, trong ví dụ này chúng ta chỉ thực hiện tạo module, module hiện taị đang trống và không thể nhìn thấy được. Để kiểm tra module đã được nhận hay chưa, chúng ta hãy kiểm tra file app/etc/config.php, file này chứa tất cả các module đã được active. Chúng cũng không được thay đổi file này một cách thủ công. Check module is active 1$ grep Learning_FirstUnit app/etc/config.php 7. Kết luận. Lại là một bài viết đơn giản siêu siêu beginer cho các bạn mới mày mò tìm hiểu magento, thực hiện các bước trong bài viết, các bạn đã có thể tạo cho mình một module để bắt đầu có thể add những logic phực tạp hơn cho module trong magento. Mong bài viết sẽ có ích đối với các bạn và hãy đón chờ các bài viết tiếp theo của mình trong serries về Magento nhé. Ciao! Bài viết tham khảo https://devdocs.magento.com/videos/fundamentals/create-a-new-module/","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Create A New Page In Magento2","slug":"create-a-new-page-in-magento2","date":"2021-07-17T07:06:27.037Z","updated":"2021-07-20T04:41:33.122Z","comments":false,"path":"2021/07/17/create-a-new-page-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/07/17/create-a-new-page-in-magento2/","excerpt":"","text":"1. Tổng quan Mở đầu series chia sẻ về Magento lần này, mình sẽ trình bày cách tạo một page mới trong magnento. Chúng ta sẽ cùng tạo một page mới trả về JSON với một tham số “HELLO WORLD!” nhé. :D Để thêm một page mới trong magento2, chúng ta phải tạo một controller. Trong Magento2, một controller là một file được đặt ở một nơi được quy định để magento có thể hiểu và response một route tương ứng. Một route trong Magento2 là một URL tiêu chuẩn bao gồm 3 phần: frontName controllerName actionName Chúng ta sẽ đi vào tìm hiểu magento sẽ dựa vào 3 phần này của route như thế nào để tương ứng với một file nhất định. Các bước để tạo một new page: Tạo một module mới. Tạo file routes.xml Tạo file controller (action) Chúng ta hãy cùng đi vào cụ thể từng bước nhé. :D 2. Tạo một module mới Để tạo một module, bạn cần làm theo các bước sau: Tạo một folder cho module. Tạo file etc/module.xml Tạo file registration.php Chạy lệnh bin/magento setup:upgrade Thực hành luôn, chúng ta sẽ tạo một thư mực module tên là Learning_HelloPage123$ cd &lt;magento2_root&gt;/app/code$ mkdir Learning$ mkdir Learning/HelloPage Tạo file registration.php123456&lt;?php /*** Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.*/\\Magento\\Framework\\Component\\ComponentRegistrar::register( \\Magento\\Framework\\Component\\ComponentRegistrar::MODULE, &#x27;Learning_HelloPage&#x27;,__DIR__); Tạo file module.xml12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--/*** Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.*/--&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:Module/etc/module.xsd&quot;&gt; &lt;module name=&quot;Learning_HelloPage&quot; setup_version=&quot;0.0.1&quot;&gt; &lt;/module&gt;&lt;/config&gt; Như vậy là chúng ta đã tạo xong một module mới. Về Quy tắc đặt tên, cấu trúc thư mục, ý nghĩa của các file registration.php, module.xml mình sẽ trình bày cụ thể trong bài viết tiếp theo. 3. Tạo file routes.xml Trước khi đi vào tạo file routes.xml, chúng ta hãy cùng tìm hiểu xem một route hoạt động thế nào trong magento2 nhé. Magento có các area, chẳng hạn như admin - liên quan đến việc hiện thị bên trang admin, frontend liên quan đến việc hiện thị giao diện phía người dùng. Mỗi một area sẽ có một file routes.xml được merge từ các file etc/area/routes.xml từ tất cả các module. File route.xml sẽ chứa tất cả các thông tin về route đựợc đăng kí và frontName. Lưu ý rằng frontName sẽ là phần đầu của một route. Để dễ hiểu hơn chúng ta hãy đi vào thực hành nhé. Bởi vì chúng ta đang tạo một page return về JSON cho user, tức là đang trong frontend area. Do đó chúng ta sẽ tạo một file ect/frontend/routes.xml cho module Learning_HelloPage12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--/*** Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.*/--&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;router id=&quot;standard&quot;&gt; &lt;route id=&quot;learning&quot; frontName=&quot;test&quot;&gt; &lt;module name=&quot;Learning_HelloPage&quot; /&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Chúng ta vừa thêm một route tên là learning.Lưu ý là tên của route không nhất thiết phải trùng với tên của module. frontName mà chúng ta tạo lfa test. Thông thường tên route và frontName là giống nhau nhưng cũng không bắt buộc phải vậy. Khi magento xử lý một route test/chunk2/chunk3, magento sẽ kiểm tra liệu trong thư mục module Learning_HelloPage có thư mục Controller/Chunk2 hay không. Tiếp đến trong thư mục Chunk2 có action file Chunk3 hay không. Ở đây route của chúng ta sẽ là test/page/view. Chúng ta hãy cùng tạo file Controller để magento có thể hiểu và lấy làm file xử lý route này nhé. 4. Tạo file controller (file action) Như đã nó ở bên trên, với route test/page/view, Magento sẽ tìm đến thư mục Controller/Page, tiếp đó tìm đến file View.php Chúng ta thêm controller như sau: 123$ cd &lt;magento2_root&gt;/app/code/Learning/HelloPage$ mkdir Controller$ mkdir Controller/Page Tạo action file Controller/Page/View.php: 12345678910111213141516171819202122232425262728293031323334&lt;?php /** * Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details. */namespace Learning\\HelloPage\\Controller\\Page;class View extends \\Magento\\Framework\\App\\Action\\Action&#123; /** * @var \\Magento\\Framework\\Controller\\Result\\JsonFactory */ protected $resultJsonFactory; /** * @param \\Magento\\Framework\\App\\Action\\Context $context * @param \\Magento\\Framework\\Controller\\Result\\JsonFactory $resultJsonFactory */ public function __construct( \\Magento\\Framework\\App\\Action\\Context $context, \\Magento\\Framework\\Controller\\Result\\JsonFactory $resultJsonFactory)&#123; $this-&gt;resultJsonFactory = $resultJsonFactory; parent::__construct($context);&#125; /** * View page action * * @return \\Magento\\Framework\\Controller\\ResultInterface */ public function execute() &#123; $result = $this-&gt;resultJsonFactory-&gt;create(); $data = [&#x27;message&#x27; =&gt; &#x27;Hello world!&#x27;];return $result-&gt;setData($data);&#125; &#125; Việc còn lại là active module và page của chúng ta bằng cách chạy câu lệnh Magento setup uprade 12$ cd &lt;magento2_root&gt;$ php bin/magento setup:upgrade Đến đây chúng ta có thể test page của chúng ta bằng cách gõ đường link /test/page/view. Chúng ta sẽ nhìn thấy message hiện lên trên trang 1&#123; &quot;message&quot;: &quot;Hello world!&quot; &#125; Ở bài viết này chủ yếu đi vào cách tạo một page mới nên chúng ta xây dựng một trang trả về một ResultJson. Ngoài ra magento2 có rất nhiều kiểu Result Object cho các trừờng hợp khác như ResultPage, Forward Result… 5. Tổng kết. Bài viết là một bài cơ bản, đơn giản về cách tạo một page trong Magento2. Mong bài viết sẽ hữu ích cho các bạn beginner bắt đầu mày mò nghiên cứu về magento. Mình cũng mới dấn thân vào con đường Magento nên mong các bạn góp ý cho bài viết và hãy cùng mình học tập tìm hiểu về magento trong những bài viết tiếp theo nhé. see ya! Bài viết tham khảo https://devdocs.magento.com/videos/fundamentals/create-a-new-page/","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Thực thi truy vấn GraphQL trên Server","slug":"graphql-server-execution","date":"2021-04-21T04:46:57.000Z","updated":"2021-07-23T04:49:06.127Z","comments":true,"path":"2021/04/21/graphql-server-execution/","link":"","permalink":"https://huongvnq.github.io/2021/04/21/graphql-server-execution/","excerpt":"","text":"1. Giới thiệu chung Khi Client gọi các câu truy vấn GraphQL, các câu truy vấn này sẽ trải qua quá trình validation dựa vào Type System (Schema). Nếu câu truy vấn là hợp lệ, nó sẽ được thực thi bởi GraphQL Server, sau đó server sẽ trả về kết quả mang “hình dáng” của câu query mà Client yêu cầu, kết quả trả về là kiểu Json. GraphQL không thể thực thi Query mà không có Schema. Chúng ta hãy cùng sử dụng ví dụ Schema sau để minh họa việc thực thi một truy vấn. 1234567891011121314151617181920type Query &#123; human(id: ID!): Human&#125;type Human &#123; name: String appearsIn: [Episode] starships: [Starship]&#125;enum Episode &#123; NEWHOPE EMPIRE JEDI&#125;type Starship &#123; name: String&#125; Để mô tả điều gì xảy ra khi một query được thực thi, chúng ta hãy thực hiện một câu query phía client như sau 123456789&#123; human(id: 1002) &#123; name appearsIn starships &#123; name &#125; &#125;&#125; Kết quả server trả về như sau 12345678910111213141516&#123; &quot;data&quot;: &#123; &quot;human&quot;: &#123; &quot;name&quot;: &quot;Han Solo&quot;, &quot;appearsIn&quot;: [&quot;NEWHOPE&quot;, &quot;EMPIRE&quot;, &quot;JEDI&quot;], &quot;starships&quot;: [ &#123; &quot;name&quot;: &quot;Millenium Falcon&quot; &#125;, &#123; &quot;name&quot;: &quot;Imperial shuttle&quot; &#125; ] &#125; &#125;&#125; Mỗi một trường trong query như là một function hay method của type cha để trả về type con. Chẳng hạn như name là một function của type human để trả về type name của human. Mỗi field trên mỗi type có một function chịu trách nhiệm xử lý phía backend gọi là resolver. Khi một field được thực thi, resolver tương ứng sẽ được gọi để trả về value cho các filed con tiếp theo. Nếu một field là một loại scalar như là một string hay một number, thì việc thực thi hoàn thành. Còn nếu một field trả về một object value, thì việc thực thi sẽ lại được tiếp tục trên các field của object đó, cứ tiếp tục như vậy cho đến khi đạt được các scalar value. GraphQL Query luôn luôn kết thúc ở các scalar value. 2. Root fields &amp; Resolvers Ở level cao nhất của một GraphQL Server chính là Root type hay còn gọi Query type, nó đại diện cho các entry point của GraphQL API. Ở ví dụ dưới đây, Query type định nghĩa một field human nhận vào tham số là id. Trên server, định nghĩa một function resolver cho field human này, function này đại khái sẽ truy xuất database lấy ra dữ liệu, khởi tạo và trả về một đối tượng Human1234567Query: &#123; human(obj, args, context, info) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) &#125;&#125; Ví dụ bên trên được viết với ngôn ngữ JavaScript, tuy nhiên bạn có thể xây dựng một GraphQL Server bằng nhiều ngôn ngữ khác. Tuy nhiên dù thế nào thì một resolver function sẽ nhận vào 4 tham số obj: Đối tượng trả về từ field cha. args: Một object chứa tất cả các tham số GraphQL cung cấp cho field này. context: Một object chia sẻ giữa tất cả các resolver bao gồm các thông tin liên quan đến ngữ cảnh như thông tin người dùng đăng nhập, kết nối cơ sở dữ liệu … info 3. Trivial Resolvers (Những hàm resolver “easy to solve”) Khi object Human được trả về cho trường human, GraphQL sẽ thực thi tiếp cho những field là field con của field human12345Human: &#123; name(obj, args, context, info) &#123; return obj.name &#125;&#125; GraphQL mạnh mẽ với hệ thống type system được định nghĩa trước, được sử dụng để GraphQL quyết định cái gì làm tiếp theo. Thậm chí, trước cả khi human field return bất cứ cái gì, GraphQL cũng biết bước tiếp theo là resolve những field của Human bởi vì type system sẽ nói cho GraphQL biết rằng fielđ human sẽ trả về Human Việc giải quyết cho trường name trong ví dụ bên trước rất là đơn giản, rõ ràng. Function resolver cho trường name được gọi, ở đây obj chính là object new Human trả về từ field đằng trước (field cha, field human). Function sẽ chả về trường name truy vấn trên đối tượng obj Lưu ý : Trong thực tế nhiều thư viện GraphQL sẽ bỏ đi những hàm resolver đơn giản như trên. Nếu hàm resolver được chỉ đinh, GraphQL sẽ thực thi hàm resolver đó, nếu không thì GraphQL sẽ ngầm hiểu để đọc và trả về một trường cùng tên (cụ thể trong ví dụ trên, GraphQL sẽ ngầm hiểu và trả về trường name của object Human cho field name là field con của field Human). 4. Scalar coercion (cưỡng chế vô hướng) Trong khi field name được resolve, thì các field appearsIn và starships cũng được thực thi đồng thời. Hàm thực thi của field appearsIn có thể cũng là một hàm trivival resolver12345Human: &#123; appearsIn(obj) &#123; return obj.appearsIn // returns [ 4, 5, 6 ] &#125;&#125; Ở đây chú ý rằng, type system đã yêu cầu appearsIn phải trả về kiểu Enum Episode. Tuy nhiên function resolver lại return về numbers! Điều hay ho ở đây là chúng ta hãy xem lại kết quả trả về cho client đã được show ở phần đầu của bài viết, chúng ta sẽ thấy kết quả trả về sẽ tương ứng với các giá trị của Enum Đây là một ví dụ về Scalar Coercion. Type System sẽ dựa vào schema để biết được cái gì được mong đợi trả về và sẽ convert giá trị trả về bởi resolver để phù hợp với “hợp đồng” 5. Kết quả trả về cho client. Khi mỗi field được resolve, kết quả sẽ được trả về theo định dạng key-value. Key là tên field hoặc alias, value là giá trị trả về của resolver Kết quả sẽ theo đúng cấu trúc mà client yêu cầu trong truy vấn truyền lên. 6. Kết luận Ở bài viết này mình đã trình bày tổng quan về các mà GraphQL server thực hiện để đáp ứng yêu cầu phía Client. Nói chung GraphQL Server phải định nghĩa các hàm resolver để xử lý trả về dữ liệu cho các field (từ Root field đến các field con) Mong bài viết sẽ truyền đạt được nội dung một cách ngắn gọn nhất đến các bạn và mong nhận được góp ý nếu có chỗ nào chưa chính xác. Nguồn tham khảo https://graphql.org/learn/execution/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"resolve","slug":"resolve","permalink":"https://huongvnq.github.io/tags/resolve/"}]},{"title":"GraphQL Fragment","slug":"graphql-fragment","date":"2021-03-20T04:40:46.000Z","updated":"2021-07-23T04:45:33.600Z","comments":true,"path":"2021/03/20/graphql-fragment/","link":"","permalink":"https://huongvnq.github.io/2021/03/20/graphql-fragment/","excerpt":"","text":"1. Fragment trong GraphQL là gì? Trong GraphQL có một khái niệm hay được sử dụng là Fragment. Trong bài viết ngày hôm nay chúng ta hãy cùng đi tìm hiểu khái niệm này là như thế nào nhé. Một GraphQL Fragment là một phần tử có thể tái sử dụng trong GraphQL Query. Trong GraphQL sẽ có những lúc bạn gặp phải những tình huống mà bạn cần phải query các field giống nhau trong các câu query khác nhau. Khi mà bạn nhận thấy các câu query của bạn có nhiều các field bị lặp lại tại nhiều vị trí khác nhau. Bạn có thể tóm chúng lại thành một đơn vị có thể tái sử dụng gọi là Fragment. Một GraphQL Fragment cho phép bạn khai báo một bộ các field và sử dụng chúng trong nhiều câu query. Bạn có thể liên tưởng Fragment trong GraphQL có nét tương đồng như là function trong nhiều ngôn ngữ lập trình. Bạn khai báo function ở một chỗ và bạn gọi đến function ở nhiều chỗ dùng đến nó. Chúng đều là các phần tử tái sử dụng được. 2. Các thành phần của một Fragment Chúng ta hãy đi vào tìm hiểu các thành phần của một Fragment với cấu trúc mẫu bên dưới12345fragment Name on TypeName &#123; field1 field2 field3&#125; Một Fragment sẽ bao gồm 3 thành phần sau Name: Tên riêng biệt cho 1 Fragment (mỗi một Fragment có 1 tên riêng) TypeName: Kiểu của object trong GraphQL Schema mà Fragment được tạo ra từ đó, hay được lồng trong đó Body: Body của Fragment định nghĩa các trường nào sẽ được query (field1, field2, field3) 3. Lợi ích của việc sử dụng GraphQL FragmentTại sao Fragment lại là một khái niệm rất “cool” trong GraphQL Thứ nhất, bởi tính tái sử dụng của Fragment: Với Fragment, bạn có thể cấu trúc các câu query của bạn thành các phần tử có thể sử dụng được ở nhiều chỗ mà không cần phải viết lặp đi lặp lại. Caching: GraphQL Client tận dụng các Fragment để cung cấp các option caching. Xem thêm apollographql.com/docs/react/caching/cache-interaction/ 4. Tạo GraphQL Fragment Chúng ta hãy cùng học cách tạo một GraphQL Fragment qua một vài ví dụ nhé. Trong những ví dụ trong bài viết này, mình sử dụng Github’s public API và viết query dựa trên nó. Bạn cũng có thể chạy các câu query trên Github GraphQL Explorer1234567891011121314151617181920&#123; googleRepo: repository(owner: &quot;google&quot;, name: &quot;WebFundamentals&quot;) &#123; name owner &#123; id avatarUrl resourcePath url &#125; &#125; facebookRepo: repository(owner: &quot;facebook&quot;, name: &quot;react&quot;) &#123; name owner &#123; id avatarUrl resourcePath url &#125; &#125;&#125; Chúng ta nhận thấy ở đây là chúng ta đang query cùng các field bên trong field owner nhiều lần. Đây là lúc thích hợp để chúng ta sử dụng Fragment Chúng ta sẽ tạo một fragment gọi là ownerInfo với từ khoá fragment. Để tạo một Fragment chúng ta phải nói cho GraphQL biết rằng Fragment này được tạo ra trên field nào. Trong trường hợp này, chúng ta sẽ tạo 1 Fragment trên fieldRepositoryOwner Trong Body của Fragment, chúng ta có thể bao gồm tất cả các field của đối tượng RepositoryOwner. Ở đây chúng ta định nghĩa các field là id, avatarUrl, resourcePath, url là các field của fragment ownerInfo1234567// fragment ownerInfo for RepositoryOwner fieldsfragment ownerInfo on RepositoryOwner &#123; id avatarUrl resourcePath url&#125; 5. Sử dụng một GraphQL Fragment Chúng ta có thể sử dụng Fragment mà chúng ta sử dụng ở ví dụ trước trong phạm vi một query bằng việc sử dụng toán tử ... và theo sau là tên của Fragment 12345678910111213141516// GraphQL Query with fragments&#123; googleRepo: repository(owner: &quot;google&quot;, name: &quot;WebFundamentals&quot;) &#123; name owner &#123; ...ownerInfo //fragment &#125; &#125; facebookRepo: repository(owner: &quot;facebook&quot;, name: &quot;react&quot;) &#123; name owner &#123; ...ownerInfo //fragment &#125; &#125;&#125; Response của query khi chúng ta sử dụng Fragment sẽ không thay đổi so với khi chúng ta không sử dụng Fragment. Fragment chỉ đơn giản là làm cho câu query được clean hơn, dễ đọc, và tái sử dụng 123456789101112131415161718192021222324// GraphQL JSON Response&#123; &quot;data&quot;: &#123; &quot;googleRepo&quot;: &#123; &quot;name&quot;: &quot;WebFundamentals&quot;, &quot;owner&quot;: &#123; &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ=&quot;, &quot;avatarUrl&quot;: &quot;https://avatars1.githubusercontent.com/u/1342004?v=4&quot;, &quot;resourcePath&quot;: &quot;/google&quot;, &quot;url&quot;: &quot;https://github.com/google&quot; &#125; &#125;, &quot;facebookRepo&quot;: &#123; &quot;name&quot;: &quot;react&quot;, &quot;owner&quot;: &#123; &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;, &quot;avatarUrl&quot;: &quot;https://avatars3.githubusercontent.com/u/69631?v=4&quot;, &quot;resourcePath&quot;: &quot;/facebook&quot;, &quot;url&quot;: &quot;https://github.com/facebook&quot; &#125; &#125; &#125;&#125; 6. Kết luận Fragment là một khái niệm rất thú vị trong GraphQL, nó cho phép tái sử dụng trong khi viết các câu query, loại bỏ các đoạn mã phải viết đi viết lại, giúp các câu query dễ đọc dễ hiểu hơn. Mong qua bài viết này, các bạn sẽ hiểu hơn về khái niệm Fragment và có thể sử dụng Fragment khi viết GraphQL Schema cũng như không bỡ ngỡ mỗi khi đọc Schema có sử dụng Fragment Nguồn tham khảo https://blog.logrocket.com/graphql-fragments-explained/ https://graphql.org/learn/queries/#fragments","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"fragment","slug":"fragment","permalink":"https://huongvnq.github.io/tags/fragment/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"}]},{"title":"GraphQL SDL - Schema Definition Language Phần 2","slug":"graphql-sdl-2","date":"2021-02-21T04:33:14.000Z","updated":"2021-07-23T04:39:43.912Z","comments":true,"path":"2021/02/21/graphql-sdl-2/","link":"","permalink":"https://huongvnq.github.io/2021/02/21/graphql-sdl-2/","excerpt":"","text":"Nối tiếp Phần một về Schema Difinition Language của GraphQL, bài viết này trình bày tiếp các khái niệm được sử dụng để định nghĩa GraphQL Schema 1. Interfaces Cũng giống như khái niệm Interface ở các language khác, trong GraphQL, một Interface là một asbstract type có thể bao gồm một tập nhất định các field mà các type khi implement nó cũng phải bao gồm các field đó. Ví dụ, bạn có một interface Character đại diện cho bất kì nhân vật nào trong Star Wars 123456interface Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]!&#125; Bất kì type nào mà Implements Characters cần phải có đầy đủ các trường trên với cùng tham số hay cùng type. Ví dụ, các type sau đây có thể implement Character 12345678910111213141516type Human implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int&#125;type Droid implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String&#125; Cả 3 type này đều có tất cả các trường từ Character interface, đồng thời cũng có các trường bổ sung như totalCredits, starships, primaryFunction giúp xác định các loại Character cụ thể. Interface hữu ích khi mà bạn muốn trả về một object hay là một bộ các object, nhưng chúng lại có các trường khác nhau. Ví dụ, câu query sau sẽ sinh ra lỗi QUERY DEFINITION 123type Query &#123; hero(episode: Episode): Character&#125; CLIENT CALL QUERY 123456query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name primaryFunction &#125;&#125; VARIABLES 123&#123; &quot;ep&quot;: &quot;JEDI&quot;&#125; RESULT 12345678910111213&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;Cannot query field \\&quot;primaryFunction\\&quot; on type \\&quot;Character\\&quot;. Did you mean to use an inline fragment on \\&quot;Droid\\&quot;?&quot;, &quot;locations&quot;: [ &#123; &quot;line&quot;: 4, &quot;column&quot;: 5 &#125; ] &#125; ]&#125; Trường hero trả về một kiểu Character, nó có thể là Human hay Droid tùy thuộc vào biến episode. Trong câu query trên bạn chỉ có thể chỉ định trả về những field mà tồn tại trong Character interface, như vậy sẽ không có primaryFunction Để yêu cầu trả về các trường trong một object type cụ thể, sử dụng inline fragments 2. Union types Ví dụ 1union SearchResult = Human | Droid | Starship Bất cứ khi nào chúng ta trả về một loại Search Result trong schema, SearchResult này có thể là một Human, Droid, hoặc một Starship. Các thành phần của một union type cần phải là một loại đối tượng cụ thể, không được là một interface hay là một union khác Khi phía client query một field mà trả về một union type là SearchResult, chúng ta cần phải sử dụng inline fragment để có thể query bất kì trường nào. CLIENT QERRY 1234567891011121314151617&#123; search(text: &quot;an&quot;) &#123; __typename ... on Human &#123; name height &#125; ... on Droid &#123; name primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125; RESULT 123456789101112131415161718192021 &quot;data&quot;: &#123; &quot;search&quot;: [ &#123; &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Han Solo&quot;, &quot;height&quot;: 1.8 &#125;, &#123; &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Leia Organa&quot;, &quot;height&quot;: 1.5 &#125;, &#123; &quot;__typename&quot;: &quot;Starship&quot;, &quot;name&quot;: &quot;TIE Advanced x1&quot;, &quot;length&quot;: 9.2 &#125; ] &#125;&#125; Trường __typename là một String giúp bạn phân biệt sự khác nhau giữa các object type ở Client Ở ví dụ này, vì Human và Droid cùng implement một interface chung là Character nên bạn có thể query những trường chung của 2 object type này ở chỉ một chỗ mà không cần lặp lại các trường giống nhau ở mỗi type, ví dụ sau đây cho kết quả như bên trên:123456789101112131415161718&#123; search(text: &quot;an&quot;) &#123; __typename ... on Character &#123; name &#125; ... on Human &#123; height &#125; ... on Droid &#123; primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125; Lưu ý: Trường name vẫn phải được chỉ định đối với Starship bởi Starship không phải là một Character 3.Input types Từ đầu đến giờ, chúng ta chỉ nói về truyền vào một field các argument thuộc về kiểu scalar như enums hay strings. Tuy nhiên bạn có thể truyền argument là một object phức tạp. Điều này cực kì hữu ích khi bạn muốn truyền vào toàn bộ object để tạo cái gì đó. Trong GraphQL SDL, input types nhìn sẽ giống một object types thông tường nhưng với keyword input thay vì type 1234input ReviewInput &#123; stars: Int! commentary: String&#125; Ví dụ sử dụng input type trong một mutation MUTATION DEFINITION 123456mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125; VARIABLES 1234567&#123; &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125;&#125; RESULT 12345678&#123; &quot;data&quot;: &#123; &quot;createReview&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125; &#125;&#125; 4. Kết luận Quan hai phần của chủ đề này, mình đã trình bày các khái niệm được sử dụng trong Schema Difinition Language. Mình tin là những khái niệm này đủ để bạn có thể tự định nghĩa một schema cơ bản của mình. Mong bài viết có ích đối với các bạn Nguồn tham khảo https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51 https://graphql.org/learn/schema","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"}]},{"title":"GraphQL SDL - Schema Definition Language Phần 1","slug":"graphql-sdl-1","date":"2021-02-21T04:29:05.000Z","updated":"2021-07-23T04:32:00.536Z","comments":true,"path":"2021/02/21/graphql-sdl-1/","link":"","permalink":"https://huongvnq.github.io/2021/02/21/graphql-sdl-1/","excerpt":"","text":"1. GraphQL Schema Difinition Language là gì? Qua các bài viết trước trong series về GraphQL, chúng ta đã hiểu được các khái niệm GraphQL, Schema. GraphQL có một ngôn ngữ riêng để định nghĩa Schema đó là GraphQL Schema Definition Language (SDL) SDL là một ngôn ngữ có cú pháp rất đơn giản, dễ hiểu đồng thời cũng rất mạnh mẽ và trực quan giúp định nghĩa schema một các cô đọng nhất. Ví dụ sử dụng SDL để định nghĩa Schema cho một ứng dụng blogging đơn giản12345678910111213type Post &#123; id: String! title: String! publishedAt: DateTime! likes: Int! @default(value: 0) blog: Blog @relation(name: &quot;Posts&quot;)&#125;type Blog &#123; id: String! name: String! description: String posts: [Post!]! @relation(name: &quot;Posts&quot;)&#125; Các thành phần chính của bản định nghĩa schema gồm có types và fields. Ngoài ra các thông tin bổ sung khác có thể được cung cấp là các custom directives như @default value được chỉ định cho trường likes hay @relation chỉ định mối quan hệ … Có rất nhiều thứ để nói ở đây, chúng ta hãy đi vào tìm hiểu chi tiết nhé. 2. Object types và fields Phần tử cơ bản nhất của GrapQL Schema là object types, đại diện cho một loại đối tượng mà bạn có thể lấy được từ server. Ví dụ1234type Character &#123; name: String! appearsIn: [Episode!]!&#125; Character là một GraphQL Object Type, là một kiểu đối tượng với các trường (field). Hầu hết các type trong schema của bạn đều là các object types name và appearsIn là các field của Character. Điều này có nghĩa là name và appearsIn là các trường duy nhất được chỉ định khi truy vấn Character Một field thì gồm có name và type. String ở đây là type của field name, là một scalar type được xây dựng sẵn. Chúng ta sẽ đi vào tìm hiểu về scalar type ở bên dưới nhé. Một field ngoài có kiểu scalar type thì có thể thuộc về bất kì kiểu nào tự định nghĩa trong schema. Một field không thể null được biểu thị bằng dấu ! , server bắt buộc phải trả về dữ liệu cho trường này khi bạn query. Một field có kiểu là mảng được chỉ định bằng [], ở đây appearsIn là một mảng các Episode. 3. Arguments Mỗi một trường của một object type có thể không có hoặc có nhiều các đối số. VÍ dụ như trường lenght bên dưới:12345type Starship &#123; id: ID! name: String! length(unit: LengthUnit = METER): Float&#125; Không giống các ngôn ngữ lập trình khác như JavaScript hay Python, các function sẽ nhận các tham số theo thứ tự khi định nghĩa functon, trong GraphQL, các field sẽ nhận các tham số theo tên được truyền vào, thứ tự các tham số không ảnh hưởng. Trong ví dụ trên trường length có một tham số được định nghĩa là unit Một argument có thể required hoặc không. Khi một tham số là không required, chúng ta có thể định nghĩa default value cho nó, nếu tham số unit không được truyền vào, nó sẽ có giá trị default là METER 4. Scalar types Scalar type là kiểu cho một đối tượng vô hướng, có nghĩa là đối tượng này không có sub-selections (các trường con), chúng được coi là các lá của query. Có 5 loại Scalar type được định nghĩa trong SDL Int: Một số nguyên 32-bit không dấu Float: Một số thực dấu phẩy động String: Một chỗi UTF-8 Boolean: true hoặc false ID: là một chuỗi định danh duy nhất, thường được sử dụng để lấy một object từ server Ngoài các kiểu scalar type được định sẵn, chúng ta có thể tự định nghĩa các custom scalar type. Ví dụ ta có thể định nghĩa một kiểu Date1scalar Date Đối với type Date chúng ta có thể validate hay format theo dạng Y/mm/dd, như vậy bất kì trường Date nào mà server trả về đều sẽ có dạng Y/mm/dd 5. Enumeration types Enums cũng là một kiểu đặc biệt của scalar type, được giới hạn trong một giá trị cho phép cụ thể, chúng ta có thể validate bất kì argument nào thuộc loại này chỉ có gía trị trong những giá trị cho phép. Ví dụ12345enum Episode &#123; NEWHOPE EMPIRE JEDI&#125; Với bất kì field nào có kiểu Episode thì chỉ có thể là NEWHOPE, EMPIRE, hay JEDI 6. Kết phần 1 Trong bài viết này mình đã trình bày một số khái niệmcơ bản và hay sử dụng nhất khi định nghĩa một GraphQL Schema. Sang phần 2 mình sẽ trình bày các khái niệm phức tạp hơn nhưng cũng rất quan trọng và hữu ích Nguồn tham khảo https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51 https://graphql.org/learn/schema/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"}]},{"title":"Cấu trúc cú pháp cơ bản của GraphQL","slug":"graphql-core-concepts","date":"2020-10-18T04:23:59.000Z","updated":"2021-07-23T04:50:13.033Z","comments":true,"path":"2020/10/18/graphql-core-concepts/","link":"","permalink":"https://huongvnq.github.io/2020/10/18/graphql-core-concepts/","excerpt":"","text":"1. Ngôn ngữ định nghĩa Schema - The Schema Definition Language (SDL) Như đã nói ở những bài viết trước về GraphQL, GraphQL sử dụng Schema như là một bản hợp đồng giữa Client và Server, một bản “quy chuẩn ngôn ngữ” giữa Client và Server, Client có thể dùng những cái định nghĩa trong Schema để gửi lên server lấy dữ liệu từ server và server cũng dựa vào đó để có thể biết mình làm gì và trả về kết quả gì cho Client. GraphQL có một ngôn ngữ riêng để định nghĩa Schema. Đó là Schema Definition Language (SDL) Ví dụ chúng ta có thể sử dụng SDL để định nghĩa một simple type Person:php type Person &#123; name: String! age: Int! &#125;type này có 2 trường, name và age tương ứng thuộc loại String và Int. Dấu ! theo sau kiểu dữ liệu có nghĩa là trường này là required Chúng ta cũng có thể mô tả mối quan hệ (relationship) giữa 2 trường. Ví dụ về một ứng dụng blog, một Person có thể có nhiều bài Post1234type Post &#123; title: String! author: Person!&#125; Ngược lại, ta khai báo type Person và đặt vào một chiều của mối quan hệ:php type Person &#123; name: String! age: Int! posts: [Post!]! &#125;Như bên trên, ta đã tạo một mối quan hệ one-to-many giữa Person và Post bởi trường posts trong type Person là một mảng các Post. Khai báo mối quan hệ như này giúp cho Client có thể chỉ định các cấu trúc query lồng nhau, như vậy có thể lấy được toàn bộ dữ liệu mình cần chỉ trong một endpoint và không phải dùng nhiều endpoint như REST. Để biết thêm về các cú pháp khác của SDL, tham khảo: https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51 2. Fetching Data với Queries. Khi làm việc với REST APIs, dữ liệu được load từ những endpoint được chỉ định. Mỗi endpoint có một cấu trúc được định nghĩa rõ ràng về những thông tin mà nó trả về. Đối với cách tiếp cận của GraphQL, thay vì có nhiều endpoints trả về dữ liệu cố định, GraphQL APIs chỉ dùng 1 endpoint và để cho người dùng có thể quyết định data thực sự cần để trả về. Do đó Client cần phải gửi nhiều thông tin hơn tới server để diễn tả yêu cầu về data, thông tin đó được gọi là query Ví dụ về một query mà client có thể gửi tới server 12345&#123; allPersons &#123; name &#125;&#125; allPersons được gọi là root field của query. Mọi thứ theo sau root field được gọi là payload của query. Ở đây chỉ có 1 field được chỉ định trong query payload là field name Câu query trên sẽ trả về danh sách tất cả các Person với tên của nó: 1234567&#123; &quot;allPersons&quot;: [ &#123; &quot;name&quot;: &quot;Johnny&quot; &#125;, &#123; &quot;name&quot;: &quot;Sarah&quot; &#125;, &#123; &quot;name&quot;: &quot;Alice&quot; &#125; ]&#125; Mỗi một person chỉ có trường name trong response trả về, trường age không trả về vì nó không cần thiết đối với Client. Nếu Client cũng cần trường age, tất cả những gì Client phải làm là điều chỉnh câu query và thêm trường vào payload. 123456&#123; allPersons &#123; name age &#125;&#125; Một trong những lợi thế lớn của GraphQL là nó cho phép truy vấn lồng nhau một cách tự nhiên. Ví dụ, bạn muốn load tất cả các bài posts của một Person, bạn có thể viết query như sau: 123456789&#123; allPersons &#123; name age posts &#123; title &#125; &#125;&#125; Server sẽ trả về response như sau: 123456789101112131415161718192021 &#123; &quot;allPersons&quot;: [ &#123; &quot;name&quot;: &quot;Binz&quot;, &quot;posts&quot;: [ &#123; &quot;title&quot;: &quot;GraphQL is awesome&quot; &#125;, &#123; &quot;title&quot;: &quot;Relay is a powerful GraphQL Client&quot;&#125; ] &#125;, &#123; &quot;name&quot;: &quot;Karik&quot;, &quot;posts&quot;: [ &#123; &quot;title&quot;: &quot;Let&#x27;s get started with React &amp; GraphQL&quot; &#125;, ] &#125;, &#123; &quot;name&quot;: &quot;Suboy&quot;, &quot;posts&quot;: [] &#125; ]&#125; Queries với Arguments:Trong GraphQL, mỗi field có thể có không hoặc nhiều tham số. Ví dụ, field allPersonscó thể có tham số last để chỉ trả về một số lượng nhất định person.&#123; allPersons(last: 2) &#123; name &#125; &#125; 3. Writing Data with Mutations. Bên cạnh việc request data từ server, phía Client cũng cần phải making some changes tới data được lưu ở phía backend. Với GraphQL, ta có thể sử dụng mutations để làm điều đó. Nói chung, có 3 loại mutations: tạo mới data cập nhật data đã tồn tại Xóa data đã tồn tại. Mutations tuân theo cấu trúc cú pháp giống như queries, tuy nhiên nó luôn luôn phải bắt đầu với keyword mutation. Ví dụ chúng ta tạo mới một Person:123456mutation &#123; createPerson(name: &quot;Sam&quot;, age: 23) &#123; name age &#125;&#125; Tương tự với query, mutation cũng có một root field, ở đây là createPerson. Ở đây field createPerson nhận vào 2 tham số là name và age. Theo sau root field createPerson là payload cho mutation, ở đây là 2 trương name và age, là chỉ định dữ liệu trả về phía server. Với mutation trên, Server sẽ trả về response như sau:1234&quot;createPerson&quot;: &#123; &quot;name&quot;: &quot;Sam&quot;, &quot;age&quot;: 23,&#125; 4. Realtime Với Subscriptions Một yêu cầu đối với nhiều ứng dụng hiện nay là tính realtime với server, cho phép nhận được thông báo ngay lập tức về các sự kiện quan trọng. Đối với trường hợp này GraphQL cung cấp khái niệm subscriptions. Khi một Client subscribes một event, một kết nối tới máy chủ sẽ được khởi tạo và giữ ổn định. Khi có một event cụ thể nào diễn ra, server sẽ đẩy dữ liệu tương ứng về cho client. Nếu Queries và Mutations tuân theo “request-response-cycle“, subscriptions sẽ đại điện cho stream of data (dòng chảy dữ liệu) gửi tới client. Ví dụ chúng ta subcribe một event:123456subscription &#123; newPerson &#123; name age &#125;&#125; Sau khi client gửi subscription tới server, một kết nối đã được mở giữa client và server. Sau đó bất cứ khi nào mutation tạo mới Person được thực thi, server sẽ gửi thông tin về person này tới client:123456&#123; &quot;newPerson&quot;: &#123; &quot;name&quot;: &quot;Sam&quot;, &quot;age&quot;: 23 &#125;&#125; 5. Định nghĩa Schema cho Queries, Mutations và Subscriptions. Để Client có thể sử dụng Queries, Mutations và Subscriptions như trên, chúng ta phải định nghĩa chúng ở Schema. Nói tóm lại, một schema đơn giản là một tập hợp của các GraphQL type. Ngoài các type như Post, Person mà chúng ta ví dụ ở phần 1, chúng ta còn có các type đặc biệt như: 123type Query &#123; ... &#125;type Mutation &#123; ... &#125;type Subscription &#123; ... &#125; Để Client có thể gọi được query allPersons như ở ví dụ bên trên, chúng ta phải định nghĩa chúng trong type Query: 123type Query &#123; allPersons: [Person!]!&#125; Tương tự với mutation createPerson và subscription newPerson, chúng ta sẽ có một tổng thể schema như sau: 12345678910111213141516171819202122232425type Query &#123; allPersons(last: Int): [Person!]!&#125;type Mutation &#123; createPerson(name: String!, age: Int!): Person! updatePerson(id: ID!, name: String!, age: Int): Person!&#125;type Subscription &#123; newPerson: Person!&#125;type Person &#123; id: ID! name: String! age: Int! posts: [Post!]!&#125;type Post &#123; id: ID! title: String! author: Person!&#125; 6. Một chút về Resolver. Chúng ta đã có schema (như chúng ta đã biết, schema như một hợp đồng làm việc giữa client và server), chúng ta biết cách gọi các truy vấn (được định nghĩa ở schema) từ phía client. Vậy còn phía server, làm sao để từ file schema, server biết được mình sẽ xử lý như thế nào để trả về cho client. Chúng ta sẽ có các hàm resolver. Ứng với mỗi field trong các type, sẽ có một resolver được định nghĩa để giải quyết yêu cầu phía client và trả về dữ liệu cho client. Các argument truyền vào các field cũng chính là những tham số được truyền vào resolvers. Trên đây là khái quát về resolver, mình trình bày chi tiết về resolver trong bài viết lần sau. Nguồn tham khảo: https://www.howtographql.com/basics/2-core-concepts/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"}]},{"title":"So sánh GrapQL với REST","slug":"graphql-vs-rest","date":"2020-10-18T03:57:28.000Z","updated":"2021-07-21T04:10:31.253Z","comments":false,"path":"2020/10/18/graphql-vs-rest/","link":"","permalink":"https://huongvnq.github.io/2020/10/18/graphql-vs-rest/","excerpt":"","text":"1. Giới thiệu chung Trải qua nhiều thập kỉ, REST đã trở thành một tiêu chuẩn cho thiết kế Web API. REST có những ý tưởng rất tuyệt vời như là stateless servers hay là structured access to resources. Tuy nhiên REST APIs vẫn còn chưa linh hoạt để bắt kịp với những yêu cầu thay đổi nhanh chóng phía client. GraphQL được phát triển để đáp ứng nhu cầu linh hoạt hơn và hiệu quả hơn. Nó giải quyết nhiều những thiếu sót và kém hiệu quả mà developer đã trải nghiệm được sau một thời gian làm việc với REST API. Ở bài viết lần trước mình cũng đã chia sẻ qua về GraphQL là gì, bài viết này mình sẽ đặt nó bên cạnh REST để làm nổi bật lên những ưu điểm vượt trội hơn so với REST. 2. Ưu điểm của GraphQL so với REST REST GraphQL Data Fetching Nhiều Endpoint 1 Endpoint Imperative data fetching Declarative Data Fetching Tồn tại Over Fetching và UnderFetching Giải quyết OverFetching và UnderFetching Khi yêu cầu Client thay đổi Phải Thay đổi phía server Có thể chỉ Phải Thay đổi phía Client Độ phụ thuộc giữa Backend và Frontend Không thể làm việc độc lập Có thể làm việc độc lập Phân tích sự dư thừa dữ liệu Không thể phân tích được sự dư thừa dữ liệu Có thể phân tích được sự dư thừa dữ liệu và hiệu suất của ứng dụng. 2.1 Data Fetching với GraphQL và RESTĐể làm rõ sự khác nhau giữa REST và GraphQL khi fetching data từ API, chúng ta hãy xem xét một kịch bản đơn giản sau: Với một ứng dụng blog, ứng dụng sẽ cần hiển thị list tiêu đề các bài post của một user cụ thể. Cùng màn hình đó, bạn cũng cần phải hiển thị tên của 3 followers của user đó. Hãy cùng xem cách mà REST và GraphQL xử lý. 2.1.1 Multiple Endpoint và Single Endpoint Với REST API, bạn sẽ lấy data bằng việc sử dụng nhiều endpoint. Với kịch bản trên, Bạn sẽ sử dụng 1 endpoint /users/{id} để lấy dữ liệu của user. Sau đó bạn sẽ sử dụng 1 endpoint nữa là /user/{id}/posts để lấy tất cả các bài post của user. Endpoint thứ ba sẽ là /user/{id}/followers trả về danh sách các follower của user. Với GraphQL, bạn chỉ cần đơn giản gửi một câu query tới GraphQL Server bao gồm các yêu cầu dữ liệu cụ thể. Server sẽ trả về một JSON object đáp ứng các yêu cầu client gửi lên. Chú ý rằng Cấu trúc response mà Server trả về sẽ tuân theo chính xác cấu trúc lồng nhau mà được chỉ định trong query gửi lên từ Client. 2.1.2 GraphQL giải quyết Overfetching và UnderfetchingMột vấn đề thông thường nhất gặp phải với REST là Overfetching và Underfetching. Điều này xảy ra do Client sử dụng endpoint để lấy dữ liệu về, và các endpoint thì trả về cấu trúc dữ liệu cố định. Điều này dẫn đến những khó khăn cho việc thiết kế API làm thế nào để có thể cung cấp cho client chính xác những gì mà client cần. Overfetching: Trả về dư thừa dữ liệu cho Client Overfetching có nghĩa là một Client lấy được nhiều thông tin hơn so với những gì nó cần. Ví dụ dễ hiểu một màn hình cần hiển thị danh sách các user chỉ với tên của các user đó. Nhưng với REST API, bạn gọi endpoint /users và nhận về mảng JSON các dữ liệu của user. Response có thể chứa nhiều thông tin của user như ngày sinh, địa chỉ của user…, những thông này vô dụng với client vì client chỉ cần hiển thị tên của các user. Underfetching và vấn đề n+1 Underfetching có nghĩa là một endpoint cụ thể không cung cấp đủ thông tin yêu cầu cho client. Client phải thực hiện thêm những request khác để lấy thêm dữ liệu mà nó cần. Khi đó vấn đề n+1 xảy ra khi mà đầu tiên Client cần lấy về một list các phần tử, nhưng sau đó đối với mỗi phần tử lại phải tạo một request để lấy dữ liệu yêu cầu của mỗi phần tử! Ví dụ với kịch bản ứng dụng cần hiển thị list user, và mỗi user cần hiển thị 3 followers gần nhất. Đầu tiên ứng dụng cần phải gọi 1 endpoint /users và sau đó ứng với mỗi user, chúng ta phải thực hiện một endpoint bổ sung là /users//followers Với việc sử dụng 1 endpoint, cho phép client chỉ định những dữ liệu nào mà client cần, server trả về đúng dữ liệu theo cấu trúc lồng nhau được chỉ định trong query của client thì GraphQL đã giải quyết được vấn đề Overfetching và Underfetching. 2.1.3 Imperative data fetching và Declarative Data Fetching REST theo phương pháp Imperative data fetching (Tìm nạp dữ liệu mệnh lệnh). Khi fetching data từ REST API, một ứng dụng cần phải thực hiện các bước sau: Gửi dữ liệu HTTP request (vd fetch trong javascript) Nhận và parse dữ liệu nhận được từ server. Store dữ liệu dưới local. Hiển thị dữ liệu trên UI GraphQL tiếp cận theo ý tưởng declarative data fetching (Tìm nạp dữ liệu khai báo), Client chỉ việc thực hiện 2 bước sau: Mô tả yêu cầu dữ liệu. Hiển thị dữ liệu trên UI. Cách tiếp cận này tập trung vào việc Client sẽ khai báo dữ liệu (declarative data), còn trừu tượng hóa các tác vụ khác cũng như việc lưu trữ dữ liệu. 2.2 Vấn đề đáp ứng sự thay đổi nhanh chóng phía Client. Với REST API, Client sẽ gọi các endpoint tương ứng cho các view, server sẽ trả về tất cả các thông tin được yêu cầu cho một view cụ thể. Tuy nhiên điểm yếu của REST API ở chỗ này là nó sẽ không đáp ứng nhanh chóng sự thay đổi phía Client. Với mỗi sự thay đổi phía UI (chẳng hạn như yêu cầu nhiều dữ liệu hơn), thì phía backend (server) cũng phải thay đổi để đáp ứng yêu cầu dữ liệu mới. Nó sẽ làm giảm hiệu suất, và chậm việc update product liên tục. Với GraphQL, vấn đề này đã được giải quyết. Nhờ có sự linh hoạt phía GraphQL, sự thay đổi phía Client sẽ không dẫn đến phải thay đổi phía server, bởi client có thể chỉ định chính xác yêu cầu dữ liệu mà client cần, do đó chỉ việc thay đổi phía Client. 2.3 Độ phụ thuộc giữa Backend và Frontend - Lợi thế của Schema và Type của GraphQL GraphQL sử dụng hệ thống Type và sử dụng Schema Definition Language (SDL) để định nghĩa Schema. Hãy hiểu Schema như là một hợp đồng giữa Client và Server, một bản mô tả cách mà client có thể lấy dữ liệu trên Server. Một khi Schema đã được định nghĩa, team frontend và team backend có thể làm việc độc lập và không cần trao đổi với nhau nhiều vì cả 2 bên đã biết được cấu trúc dữ liệu sẽ được transfer như nào. Team Frontend có thể tạo dummy test data để test ứng dụng và khi server đã sẵn sàng, team frontend sẽ chuyển sang lấy dữ liệu từ API thực tế. Điều này giúp tăng hiệu suất làm việc rất nhiều. 2.4 Phân tích sự dư thừa dữ liệu Với REST API, chúng ta có toàn bộ dữ liệu được trả về trong một API endpoint, như vậy chúng ta sẽ không biết được thông tin về việc sử dụng các trường dữ liệu cụ thể. Đối với GraphQL, chúng ta sẽ chỉ định chính xác những gì chúng ta cần, như vậy chúng ta sẽ biết được trường dữ liệu nào đang được sử dụng và trường dữ liệu nào không được request từ Client nữa. Hơn nữa, GraphQL sử dụng resolver function để xử lý dữ liệu mà client yêu cầu. Các phương pháp đo lường hiệu suất cho các resolvers sẽ giúp bạn nhìn thấy được những chỗ “cổ chai” trong ứng dụng của bạn, giúp bạn có thể theo dõi được performance của hệ thống. 3. Nhược điểm của GraphQL GraphQL luôn trả về HTTP status code là 200, bất kể query có success hay không. Nếu query fail, JSON response trả về sẽ có key errors, với các error message và stacktrace. Điều này gây khó khăn hơn trong việc error handling. Phải thiết kế Schema trước, sẽ vất vả hơn vì thêm việc mặc dù sau này schema sẽ giúp bạn ngăn chặn nhiều lỗi và đỡ tốn sức hơn khi nâng cấp. Khi Client không cần quan tâm đến data lấy từ đâu thì Sự phức tạp được đẩy về phía server, GraphQL không phải là giải pháp tốt cho các ứng dụng đơn giản. Vấn đề caching. REST API sử dụng nhiều endpoint nên nó tận dùng HTTP caching để tránh việc phải tìm nạp lại tài nguyên. Với GraphQL, nó sử dụng 1endpoint thay vì theo cơ chế caching của HTTP. Lưu vào bộ nhớ đệm là rất quan trọng vì nó làm giảm sự truy cập vào máy chủ. Với GraphQL, bạn phải sử dụng thư viện khác phía Client để đáp ứng việc caching. 4. Kết luận Bài viết trên mình đã trình bày sự khác nhau giữa REST và GraphQL qua những ưu nhược điểm của GraphQL so với REST. Cả REST và GraphQL đều là những cách nổi bật để thiết kế API. REST đơn giản hóa đáng kể công việc của dev với cách tiếp cận tiêu chuẩn, tuy nhiên nó cũng có vài nhược điểm. GraphQL giải quyết những nhược điểm của REST và có nhiều ưu điểm vượt trội hơn so với REST, tuy nhiên không phải lúc nào nó cũng là giải pháp tốt nhất. Đối với những ứng dụng xử lý dữ liệu tương đối nhất quán, mình nghĩ nên sử dụng REST API. Còn đối với những ứng dụng mà cần xử lý với dữ liệu thay đổi nhanh chóng, yêu cầu update product liên tục thì hãy trải nghiệm với GraphQL. Anyway, bạn có thể sử dụng cả REST và GraphQL trong 1 project. Hãy phân tích ứng dụng của bạn và yêu cầu hiệu suất để có lựa chọn thích hợp nhé. Hẹn gặp lại các bạn trong các bài viết tiếp theo của Series GraphQL. Nguồn tham khảo: https://www.howtographql.com/basics/1-graphql-is-the-better-rest/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"REST API","slug":"REST-API","permalink":"https://huongvnq.github.io/tags/REST-API/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"}]},{"title":"Giới thiệu chung về GraphQL","slug":"introduction-graphql","date":"2020-10-18T03:00:58.000Z","updated":"2021-07-21T03:33:49.623Z","comments":false,"path":"2020/10/18/introduction-graphql/","link":"","permalink":"https://huongvnq.github.io/2020/10/18/introduction-graphql/","excerpt":"","text":"1. Nhắc lại về REST REST (Representational State Transfer): được sáng lập bởi người sáng lập ra phương thức HTTP. Là một tiêu chuẩn để viết API, sử dụng phương thức HTTP đơn giản để giao tiếp giữa các máy. REST gửi một yêu cầu HTTP như GET, POST, UPDATE, DELETE đến một URL để xử lý dữ liệu REST mang lại rất nhiều ưu điểm (ứng dụng rõ ràng, code dễ dàng đơn giản hơn, dữ liêu trả về dưới nhiều định dạng…). Ttrải qua rất nhiều năm, REST là cách phổ biến nhất để client giao tiếp server. REST cũng là giải pháp phù hợp với rất nhiều ứng dụng đặc biệt là các ứng dụng đơn giản, tốc độ phát triển chậm. Tuy nhiên ngày nay, nhiều ứng dụng lại có tốc độ phát triển nhanh, thay đổi cập nhật liên tục, dẫn đến các API cũng phải thay đổi dữ liêu trả về tương ứng… Điều này dẫn đến ra đời GraphQL 2. GraphQL là gì? Là một tiêu chuẩn API mới cung cấp một giải pháp thay thế hiệu quả, mạnh mẽ, linh hoạt hơn so với REST. Cho phép Client có thể chỉ định chính xác những data nào mà Client thật sự cần từ một API. Thay vì multiple endpoints trả về cấu trúc data cố định, GraphQL chỉ sử dụng Một endpoint, và trả về chính xác dữ liệu mà client yêu cầu. GraphQL thường bị nhầm tưởng là một công nghệ Database. Điều đó là quan niệm sai lầm. GraphQL là một query language cho API, không phải cho database. Điều đó có nghĩa là chúng ta có thể sử dụng GraphQL mà không cần quan tâm database là gì. 3. Tại sao lại phát triển GraphQL Sự ra tăng của các việc sử dụng các thiết bị mobile, nhiều thiết bị mobile công suất thấp, mạng yếu, đòi hỏi cần phải load dữ liệu một cách hiệu quả.Đây là lý do Facebook sáng chế ra GraphQL. GraphQL giảm thiểu số lượng data transfer qua mạng. Có nhiều các framework và platform frontend khác nhau.Gây khó khăn cho việc xây dựng và bảo trì một API mà đáp ứng yêu cầu của các framework và platform. Với GraphQL, mỗi client có thể truy cập chính xác đc dữ liệu nó cần. Đáp ứng sự triển khai nhanh chóng liên tục và cập nhật product thường xuyên.Với Rest API, phía máy chủ cần được sửa đổi để giải quyết các yêu cầu cụ thể và thay đổi design phía clients. Điều này cản trở yêu cầu triển khai nhanh chóng và liên tục. 4. Câu chuyện về GraphQL GraphQL được sáng chế bởi Facebook. Facebook bắt đầu sử dụng GraphQL vào năm 2012 trong các ứng dụng mobile native của họ. Lần đầu tiên Facebook phát ngôn chính thức về nó là ở React.js Conf 2015 và ngay sau đó họ đã open source nó. Tại vì Facebook luôn nói về GraphQL trong bối cảnh của ReactJS nên tại thời điểm đó nhiều người chỉ nghĩ rằng GraphQL chỉ giới hạn sử dụng cho React, nhưng không phải vậy, thực tế GraphQL là một công nghệ mà có thể sử dụng mọi nơi Client giao tiếp với API. GraphQL có một cộng đồng phát triển nhanh chóng: Trước khi Facebook công bố GraphQL, thì các công ty khác như Netflix hay Coursera cũng đang phát triển những ý tưởng tương đồng với mục đích làm cho tương tác với API hiệu quả hơn. Coursera cũng đã hình dung ra một công nghệ tương tự cho phép client chỉ định những yêu cầu về dữ liệu trả về. Còn Netflix thì thậm chí cũng đã open-source giải pháp của họ gọi là Falcor. Tuy nhiên sau khi GraphQL đc open-source, Coursera đã từ bỏ nỗ lực của họ và nhảy sang dùng GraphQL. Ngày nay GraphQL được sử dụng bởi nhiều công ty khác nhau như GitHub, Twitter, Shopify, Yelp… 5. Kết luận Bài viết này mình đã giới thiệu chung về GraphQL, với mong muốn mọi người hiểu được GraphQL là gì, Tại sao nó lại ra đời. Mình cũng muốn nhấn mạnh là GraphQL là một query language cho API, nó ra đời để khắc phục những thiếu sót và nhược điểm của REST. Bài viết sau mình sẽ đi vào so sánh GraphQL và REST để làm rõ hơn sự khác nhau giữa GraphQL và REST cũng như những ưu điểm của GraphQL. Nguồn tham khảo: https://www.howtographql.com/basics/0-introduction/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"Facebook Graph API","slug":"Facebook-Graph-API","permalink":"https://huongvnq.github.io/tags/Facebook-Graph-API/"}]}],"categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"},{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"resolve","slug":"resolve","permalink":"https://huongvnq.github.io/tags/resolve/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"fragment","slug":"fragment","permalink":"https://huongvnq.github.io/tags/fragment/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"},{"name":"REST API","slug":"REST-API","permalink":"https://huongvnq.github.io/tags/REST-API/"},{"name":"Facebook Graph API","slug":"Facebook-Graph-API","permalink":"https://huongvnq.github.io/tags/Facebook-Graph-API/"}]}