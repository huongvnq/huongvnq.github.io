{"meta":{"title":"Meditation Coding","subtitle":"","description":"","author":"HuongVNQ","url":"https://huongvnq.github.io","root":"/"},"pages":[{"title":"About","date":"2021-07-18T02:39:35.000Z","updated":"2021-07-21T03:49:02.252Z","comments":false,"path":"about/index.html","permalink":"https://huongvnq.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-07-18T01:49:17.000Z","updated":"2021-07-18T02:36:42.989Z","comments":true,"path":"categories/index.html","permalink":"https://huongvnq.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-07-18T02:02:02.000Z","updated":"2021-07-18T08:59:38.632Z","comments":true,"path":"tags/index.html","permalink":"https://huongvnq.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JWT Authentication & Authorization in NodeJs REST API","slug":"jwt-nodejs","date":"2021-08-25T09:44:45.000Z","updated":"2021-08-25T09:57:10.789Z","comments":true,"path":"2021/08/25/jwt-nodejs/","link":"","permalink":"https://huongvnq.github.io/2021/08/25/jwt-nodejs/","excerpt":"","text":"1. Lời mở đầu Trong bài viết này, mình sẽ tạo một REST API cho phép chúng ta tạo user, đăng kí, đăng nhập, lấy thông tin user đăng nhập, logout một người dùng ở một thiết bị và log out từ nhiều thiết bị. Công nghệ mà chúng ta sử dụng là Node.js với Express, MongoDB. Với MongoDB các bạn có thể cài đặt cơ sở dữ liệu MongDB local, tuy nhiên bạn cũng có thể sử dụng MongoDB Atlas (một clould database serive) như bài viết này. 2. Các bước thực hiện2.1 Tạo một MongoDB database với MongoDB AtlasBước này các bạn có thể tham khảo hướng dẫn tại đâyhttps://www.freecodecamp.org/learn/apis-and-microservices/mongodb-and-mongoose/ 2.2 Thiết lập cấu trúc thư mục cho project Tạo một thư mục, ở đây mình đặt tên là user-registration-api. Hãy cùng xem cấu trúc thư mục của project nhé Chúng ta có một thư mục gốc là src. Bên trong thư mục này có: File app.js: nơi thiết lập server express. Thư mục models chứa tất cả models mà chúng ta sử dụng với Mongoose, trong phạm vi project này chúng ta có model User. Thư mục db chứa tất cả các cấu hình kết nối với database. Thư mục middleware sẽ chứa các middleware. Đối với project này chúng ta sẽ tạo một middleware auth giúp chúng ta có những endpoint được bảo vệ. Để thực hiện project này chúng ta cần cài đặt Node.js, hãy cài đặt phiên bản mới nhất của node. Npm được dùng để cài đặt và quản lý các package của node. Có nhiều Package quản lí khác mà bạn có thể sử dụng và ở đây chúng ta sẽ sử dụng yarn. Cài đặt yarn bằng npm với câu lệnh: npm install yarn -g Init project Node: yarn initCâu lệnh này sẽ tạo ra một file package.json sẽ liệt kê tất cả các package của project 2.3 Cài đặt các package cần thiết Trong project này chúng ta cần các package sau: Express.js: Một framework node.js giúp bạn dễ dàng build một ứng dụng web. mongodb: Một driver MongoDB dành cho Node.js mongoose: Một công cụ mô hình hóa đối tượng (object modeling) được thiết kế để làm việc với môi trường không đồng bộ. Chúng ta sẽ sử dụng mongoose để định nghĩa cấu trúc database và tương tác với database. bcrypt.js: Dùng để mã hóa (hash) mật khẩu của user trước khi lưu chúng trong database. validator: Chúng ta sử dụng package này để validate input của user. Ví dụ như đảm bảo rằng người dùng đưa ra một input là một email đúng định dạng Jsonwebtoken - JSON Web Token (JWT) sẽ sử dụng để authentication và authorization (để hiểu rõ hơn 2 cái này là gì và khác biệt như thế nào các bạn hãy đọc thêm http://www.differencebetween.net/technology/difference-between-authentication-and-authorization/). Chẳng hạn Package này sẽ giúp chúng ta thiết lập những route được bảo vệ mà chỉ những user đã đăng nhập mới được truy cập. env-cmd: Package này sẽ cho chúng ta tạo và quản lý những biến môi trường trong project nodemon: Nodemon sẽ chạy lại express server mỗi khi chúng ta thay đổi code. Để cài đặt những package trên: 1yarn add express mongodb mongoose bcryptjs validator jsonwebtoken Đối với nodemon và env-cmd chúng ta cài đặt như là các development dependency: 1yarn add env-cmd nodemon --dev Tạo file .env ở trong thư mục gốc cùng bậc với thư mục src, để đinh nghĩa tất cả các biến môi trường. Mở file package.json và thêm vào đoạn script sau ngay sau dòng main:index.js. 1&quot;scripts&quot;:&#123;&quot;start&quot; : &quot;env-cmd -f ./.env nodemon src/app.js&quot;&#125; Như vậy mỗi khi ta chạy câu lệnh yarn start, chúng ta sẽ sử dụng nodemon để chạy lại server mỗi khi có thay đổi trong file src\\app.jsVà chúng ta sẽ sử dụng được các biến môi trường định nghĩa trong file .env 2.4 Định nghĩa các biến môi trường. Mở file .env và thêm những biến môi trường sau: 123MONGODB_URL=mongodb+srv://huongvnq&lt;password&gt;@cluster0-e1zyx.mongodb.net/jwt-nodejs?retryWrites=true&amp;w=majorityJWT_KEY=HuongVNQPORT=3000 Biến MONGODB_URL sẽ chứa chuỗi kết nối với cơ sở dữ liệu MongoDB mà chúng ta có được khi cấu hình MongoDB trên MongoDB Atlas đã làm ở bước 1. Chuỗi này có chứa một database username ở đây của mình là huongvnq, password khi bạn tạo database user, và tên database, ở đây của mình là jwt-nodejs. Các bạn hãy thay đổi theo cấu hình của các bạn. Biến JWT_KEY sẽ chứa JWT token mà chúng ta sẽ sử dụng để tạo authentication token của user Biến PORT chứa số cổng mà ứng dụng chạy 2.5 Tạo một express server Trong file app.js: 12345678910111213const express = require(&quot;express&quot;);const userRouter = require(&quot;./routers/user&quot;);const port = process.env.PORT;require(&quot;./db/db&quot;);const app = express();app.use(express.json());app.use(userRouter);app.listen(port, () =&gt; &#123; console.log(`Server running on port $&#123;port&#125;`);&#125;); Trong đoạn code trên, chúng ta khai báo sử dụng express, user router (mà chúng ta sẽ tạo sau này), số cổng lấy ra từ file .env, require file db.js mà chứa kết nối đến database (chúng ta sẽ tạo phía sau) Tạo một express() instance và gán nó cho biến app.Express instance sẽ cho chúng ta các methods như get, post, delete, patch để chúng ta gửi các HTTP request tới server.Và vì chúng ta xây dựng các API nên các request của chúng ta sẽ gửi đi dữ liệu và nhận dữ liệu từ server dưới dạng json Vào terminal gõ lệnh yarn start, nếu bạn thấy dòng chữ Server running on port 3000 tức là bạn đã setup thành công một server express. 2.6 Kết nối với database Mở file db/db.js, và gõ những dòng code sau: 123456const mongoose = require(&#x27;mongoose&#x27;)mongoose.connect(process.env.MONGODB_URL, &#123; useNewUrlParser: true, useCreateIndex: true,&#125;) Trong đoạn code trên chúng ta require mongoose và sử dụng method connect của mongoose, nhận vào tham số thứ nhất là chuỗi URL kết nối database, và một object option là tham số thứ 2. 2.7 Tạo model User File /models/User.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const mongoose = require(&quot;mongoose&quot;);const validator = require(&quot;validator&quot;);const bcrypt = require(&quot;bcryptjs&quot;);const jwt = require(&quot;jsonwebtoken&quot;);const userSchema = mongoose.Schema(&#123; name: &#123; type: String, required: true, trim: true &#125;, email: &#123; type: String, required: true, unique: true, lowercase: true, validate: value =&gt; &#123; if (!validator.isEmail(value)) &#123; throw new Error(&#123; error: &quot;Invalid Email address&quot; &#125;); &#125; &#125; &#125;, password: &#123; type: String, required: true, minLength: 7 &#125;, tokens: [ &#123; token: &#123; type: String, required: true &#125; &#125; ]&#125;);userSchema.pre(&quot;save&quot;, async function(next) &#123; // Hash the password before saving the user model const user = this; if (user.isModified(&quot;password&quot;)) &#123; user.password = await bcrypt.hash(user.password, 8); &#125; next();&#125;);userSchema.methods.generateAuthToken = async function() &#123; // Generate an auth token for the user const user = this; const token = jwt.sign(&#123; _id: user._id &#125;, process.env.JWT_KEY); user.tokens = user.tokens.concat(&#123; token &#125;); await user.save(); return token;&#125;;userSchema.statics.findByCredentials = async (email, password) =&gt; &#123; // Search for a user by email and password. const user = await User.findOne(&#123; email &#125;); if (!user) &#123; throw new Error(&#123; error: &quot;Invalid login credentials&quot; &#125;); &#125; const isPasswordMatch = await bcrypt.compare(password, user.password); if (!isPasswordMatch) &#123; throw new Error(&#123; error: &quot;Invalid login credentials&quot; &#125;); &#125; return user;&#125;;const User = mongoose.model(&quot;User&quot;, userSchema);module.exports = User; Dòng thứ 6, chúng ta tạo một userSchema bằng mongoose.schema(). Đây là một object định nghĩa các thuộc tính (property) khác nhau của user schema. Mongoose sẽ chuyển đổi user schema này sang document trong database MongoDb và các thuộc tính sẽ được chuyển thành các trường trong document. Ở đây khi định nghĩa các thuộc tính, chúng ta sẽ định nghĩa các đặc điểm của chúng (loại, có require hay không, có unique hay không, chữ thường hay chữ hoa…) Mongoose đã hỗ trợ chúng ta làm điều đó. Ngoài ra ta sử dụng package validators cung cấp nhiều function giúp dễ dàng định nghĩa các validate, chẳng hạn như isEmail. Chúng ta cũng lưu một danh sách các token vào database. Mỗi lần user đăng kí hay log in, chúng ta sẽ tạo một token và gắn nó vào trong danh sách token. Việc lưu một danh sách các token sẽ giúp người dùng có thể log in từ nhiều thiết bị khác nhau và một khi họ log out từ một thiết bị, chúng ta vẫn đảm bảo được họ vẫn được log in ở các thiết bị khác. Từ dòng 36 đến 43 chúng ta cũng sử dụng hàm pre-save mà mongoose cung cấp sẵn cho chúng ta. Nó cho phép chúng ta làm gì đó trước khi lưu object. Ở đây, chúng ta sẽ hash mật khẩu trước khi lưu object. Vì như bạn biết chúng ta sẽ không lưu mật khẩu của người dùng dưới dạng thô để đảm bảo tính bảo mật. Ngoài ra ở đây, chúng ta chỉ thực hiện hash password nếu chúng được thay đổi, đấy là lý do tại sao chúng ta sẽ kiểm tra password có được chỉnh sửa hay không trước. Một điều đáng lưu ý nữa, là Mongoose cho phép chúng ta định nghĩa instance method và model method Model method là các phương thức được định nghĩa trên model, được tạo ra bởi schema static. instance method định nghĩa trên instance hay cũng là document. Ở đây, chúng ta định nghĩa 1 instance method là generateAuthToken, sử dụng phương thức sign của jwt để tạo một token dựa trên JWT_KEY mà chúng ta lưu trong .env. Một khi token được tạo, chúng ta sẽ thêm nó vào danh sách token của user, lưu và trả về token. Chúng ta định nghĩa một model method là findByCredentials, nhận vào 2 tham số là user email và password. Chúng ta sẽ tìm user nào có email đó sử dụng phương thức find của mongoose. Nếu không tìm thấy user, chúng ta sẽ ném một error cho user biết rằng định danh user cung cấp không hợp lệ. Nếu email tồn tại, chúng ta tiếp tục so sánh password người dùng nhập vào với password đã được hashed trong database dựa trên cơ chế compare của bcrypt, nếu giống nhau chúng ta sẽ trả về user đó. Chúng ta sẽ sử dụng function này để cho user đăng nhập vào ứng dụng. Cuối cùng chúng ta tạo một model User sử dụng mongoose.model(&#39;User&#39;, userSchema), sau đó export ra module để có thể tái sử dụng ở các file khác. 2.8 Tạo các route cần thiết Chúng ta sẽ tạo các endpoint sau HTTP POST /users: Đăng kí user HTTP POST /users/login: User đăng nhập HTTP GET / users/me: Lấy profile của user. HTTP POST /users/logout: User đăng xuất HTTP post /users/logoutall: Đăng xuất từ tất cả các thiết bị Bắt đầu với route tạo user. File /routers/user.js: 12345678910111213141516const express = require(&quot;express&quot;);const User = require(&quot;../models/User&quot;);const router = express.Router();router.post(&quot;/users&quot;, async (req, res) =&gt; &#123; // Create a new user try &#123; const user = new User(req.body); await user.save(); const token = await user.generateAuthToken(); res.status(201).send(&#123; user, token &#125;); &#125; catch (error) &#123; res.status(400).send(error); &#125;&#125;); Route đăng kí user sẽ tạo một user theo thông tin người dùng lấy ra từ req.body. Sau khi lưu user, chúng ta sẽ tạo một authentication token và trả về trong response cùng với user data. Test bằng postman: Sử dụng type of data là JSON(application/json), nhấn vào button raw, cung cấp các trường dữ liệu require như name, email, password. Route login một user đã đăng kí: POST /users/login 12345678910111213router.post(&#x27;/users/login&#x27;, async(req, res) =&gt; &#123; //Login a registered user try &#123; const &#123; email, password &#125; = req.body const user = await User.findByCredentials(email, password) if (!user) &#123; return res.status(401).send(&#123;error: &#x27;Login failed! Check authentication credentials&#x27;&#125;) &#125; const token = await user.generateAuthToken() res.send(&#123; user, token &#125;) &#125; catch (error) &#123; res.status(400).send(error) &#125; Cung cấp một object gồm email và password cho phần body của request. Test bằng postman: 2.9 Tạo một auth middleware Middleware là một phần code như cầu nối giữa database và ứng dụng. Khi một request được gửi tới server, middleware sẽ chạy trước khi request tới server và trả về một response. Chúng ta đảm bảo rằng một người cố gắng truy cập vào nguồn resource nhất định có được ủy quền truy cập hay không. File /middleware/auth.js: 12345678910111213141516171819const jwt = require(&quot;jsonwebtoken&quot;);const User = require(&quot;../models/User&quot;);const auth = async (req, res, next) =&gt; &#123; const token = req.header(&quot;Authorization&quot;).replace(&quot;Bearer &quot;, &quot;&quot;); const data = jwt.verify(token, process.env.JWT_KEY); try &#123; const user = await User.findOne(&#123; _id: data._id, &quot;tokens.token&quot;: token &#125;); if (!user) &#123; throw new Error(); &#125; req.user = user; req.token = token; next(); &#125; catch (error) &#123; res.status(401).send(&#123; error: &quot;Not authorized to access this resource&quot; &#125;); &#125;&#125;;module.exports = auth; Một express middleware là một hàm nhận vào 3 tham số: request, response, next. Ở dòng thứ 5, chúng ta lấy token từ request header và vì token có format Bearer[space]token, chúng ta sẽ phải replace Bearer[space] với ‘’. Một khi chúng ta có token chúng ta sử dụng JWT verify method để kiểm tra token nhận được là hợp lệ chưa và có được tạo từ JWT_KEY hay không. Method verify của JWT trả về một payload mà được dùng để tạo token (ở đây token đc tạo với id của user). Bây giờ chúng ta có payload từ token, chúng ta sẽ tìm một user mà có id từ payload. Nếu tìm thấy user chúng ta sẽ gắn user vào request (req.user = user), gắn token vào request. Sau cùng, ta gọi phương thức next() để đi tới middleware tiếp theo. Nếu next() không được gọi, ứng dụng sẽ bị đông cứng ở điểm đó và sẽ không xử lý đc đoạn code còn lại tiếp theo đó. Bây giờ là lúc sử dụng middleware auth. Mở file /routers/user.js, import middleware auth bằng việc require nó đầu file sau khi require user model 1const auth = require(../middleware/auth) Route lấy profile: 1234router.get(&quot;/users/me&quot;, auth, async (req, res) =&gt; &#123; // View logged in user profile res.send(req.user);&#125;); Chỉ với 2 dòng của code chúng ta đã lấy được user profile. Dòng 1, chúng ta viết một get request tới /users/me endpoint, truyền vào auth middleware trước method để đảm bảo middleware sẽ chạy trước phần còn lại của hàm. Dòng thứ 3 chúng ta đơn giản chỉ việc lấy user profile từ request, khi middleware đã được thông qua rồi. Và gửi response trả về res.send(req.user) Test bằng postman. Nhập đúng đường URL, Chọn tab Authorization, chọn Bearer Token từ dropdown, và cung cấp authentication token phía bên phải, token này bạn nhận được sau khi login. 2.10 Logout và Logout từ tất cả các thiết bị Route logout, File /routers/user.js: 123456789101112router.post(&quot;/users/me/logout&quot;, auth, async (req, res) =&gt; &#123; // Log user out of the application try &#123; req.user.tokens = req.user.tokens.filter(token =&gt; &#123; return token.token != req.token; &#125;); await req.user.save(); res.send(); &#125; catch (error) &#123; res.status(500).send(error); &#125;&#125;); Chúng ta filter mảng token của user lấy ra những token khác với giá trị token từ request mà ta lấy được khi user login, sau đó lưu lại user. Giờ đây, khi ta get user profile, chúng ta sẽ bị từ chối truy cập bởi vì chúng ta không còn login nữa. Test bằng postman: Đầu tiên chúng ta login để lấy token từ response, sau đs qua url /users/me/logout và sử dụng token vừa lấy như là một Bearer Token. Nhấn send, một response code 200 sẽ được trả về. Khi truy cập /users/me với token mà chúng ta sử dụng để log out, chúng ta sẽ được response lỗi như dưới đây: Route logout tất cả các thiết bị: 12345678router.post(&#x27;/users/me/logoutall&#x27;, auth, async(req, res) =&gt; &#123; // Log user out of all devices try &#123; req.user.tokens.splice(0, req.user.tokens.length) await req.user.save() res.send() &#125; catch (error) &#123; res.status(500).send(error) Chúng ta sử dụng phương thức splice để remove tất cả tokens từ mảng token của user. Sau đó save document. Test bằng postman: Sử dụng /users/login login 3 lần. Bạn sẽ có 3 token trong mảng token của user. Vào /users/me để xem profile. Sử dụng /users/me/logoutall, nó sẽ xóa hết mảng token. Vào lại /users/me, bạn sẽ không thể xem được user profile được nữa. 3 Kết luận Qua bài viết trên chúng ta đã hiểu được sơ bộ token là gì và các sử dụng token để authentication và authorization, dùng token để logout từ một thiết bị và tất cả các thiết bị. Mong các bạn sẽ học được nhiều thứ từ bài viết này. Tham khảo https://medium.com/swlh/jwt-authentication-authorization-in-nodejs-express-mongodb-rest-apis-2019-ad14ec818122","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://huongvnq.github.io/categories/NodeJS/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"https://huongvnq.github.io/tags/jwt/"}]},{"title":"CRUD với NodeJs, Express và MongoDB","slug":"crud-nodejs","date":"2021-08-22T09:13:32.000Z","updated":"2021-08-25T09:45:25.154Z","comments":true,"path":"2021/08/22/crud-nodejs/","link":"","permalink":"https://huongvnq.github.io/2021/08/22/crud-nodejs/","excerpt":"","text":"1. Cài đặt môi trường B1: Tạo một thư mục dự án B2: Tạo file package.json - là file quản lý các dependency được cài đặt nội bộ. Để tạo file package.json, chúng ta cần khởi tạo npm1npm init B3: Cài đặt Express Express là một module thường được sử dụng kèm theo Node.js. Express chạy giữa server tạo bởi Node.js và các trang frontend của một ứng dụng web. Express cũng giải quyết định tuyến (routing) của ứng dụng, hướng người dùng đến đúng trang dựa trên sự tương tác của người dùng với ứng dụng. Mặc dù có nhiều lựa chọn khác ngoài express tuy nhiên Express là đơn giản nhất để tìm hiểu về sự tương tác giữa phần backend Node.js và frondend Cài đặt express1npm install express --save B4 : Tạo file app.js ở trong thư mục dự án123456789101112131415// Call in installed dependenciesconst express = require(&quot;express&quot;);// set up express appconst app = express();// set up port numberconst port = 5035;// set up home routeapp.get(&quot;/&quot;, (request, respond) =&gt; &#123; respond.status(200).json(&#123; message: &quot;Welcome to Project Support&quot; &#125;);&#125;);app.listen(port, (request, respond) =&gt; &#123; console.log(`Our server is live on $&#123;port&#125;. Yay!`);&#125;); B5: Start server1node app.js 2. Xây dựng ứng dụngTrong bài viết này, chúng ta sẽ xây dựng một ứng dụng CRUD Course (thêm sửa xóa các Course) 1. Cấu trúc thư mục Chắc hẳn bạn đã biết về mô hình MVC, ở ví dụ này chúng ta cũng sẽ xây dựng ứng dụng theo mô hình MVC bằng các tách cấu trúc thành các phần riêng biệt tùy theo chức năng của nó. Chúng ta sẽ tạo ra 3 thư mục, models sẽ chứa code tương tác với database, thư mục controllsers chứa logic của ứng dụng xử lý các request từ client và response trả về, thư mục route giải quyết việc điều hướng. 123456// create new directorymkdir server// change to server directorycd server// add three more directoriesmkdir controllers models routes 2. Cấu hình Application Entry Point (File app.js) Cài đặt các dependency 12// npm install the needed dependenciesnpm install body-parser morgan mongoose --save body-parser: Để giải quyết những HTTP POST request trong express.js từ version 4 trở lên, chúng ta cần mudule middleware body-parser. Body parser trích xuất toàn bộ phần body của request gửi đến và hiển thị chúng trên req.body mongoose: là một thư viện ODM (Object Data Modeling) cho MongDB và Node.js, được sẻ dụng để chuyển các object (đối tượng) trong code thành những biểu diễn của những object này trong MongoDB. morgan: là một công cụ logging tuyệt vời khi làm việc với HTTP server trong Node.js, là một middleware cho phép chúng ta dễ dàng log những request, error ra console. Import và set up các dependency 1234567891011// import dependenciesimport express from &quot;express&quot;;import bodyParser from &quot;body-parser&quot;;import mongoose from &quot;mongoose&quot;;import logger from &quot;morgan&quot;;// set up dependenciesconst app = express();app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(logger(&quot;dev&quot;)); Set up mongoose: Sử dụng JavaScript promise để set up mongoose và bắt lỗi. 12345678// set up mongoosemongoose.connect(&lt;Your URI&gt;, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;); .then(()=&gt; &#123; console.log(&#x27;Database connected&#x27;); &#125;) .catch((error)=&gt; &#123; console.log(&#x27;Error connecting to database&#x27;); &#125;); Lưu ý: Best practice là đặt URI ở .env và truy cập vào các biến môi trường trong file env với process.env.VAR_NAME Các bạn có thể cài đặt MongoDB về máy hoặc có thể sử dụng cloud MongoDB Atlas. Để thiết lập MongoDB Atlas và lấy URI cho Database của bạn, bạn có thể tham khảo hướng dẫn Set up cổng, định nghĩa route home và lắng nghe cổng 1234567891011// set up portconst port = 5035;// set up routeapp.get(&quot;/&quot;, (req, res) =&gt; &#123; res.status(200).json(&#123; message: &quot;Welcome to Project with Nodejs Express and MongoDB&quot; &#125;);&#125;);app.listen(port, () =&gt; &#123; console.log(`Our server is running on port $&#123;port&#125;`);&#125;); Start server: Mở terminal, ở thư mục project, chạy: 1node app.js Kết quả khi kết nối database thành công và chạy ứng dụng ở cổng 5035: 3. Tạo Model Trước tiên chúng ta sẽ đi vào ví dụ tạo Caurse. Ứng dụng cho phép nhập tiêu đề và mô tả cho course và course được tạo sẽ được lưu trong MongoDB cho phép client có thể truy xuất khi cần. Model đầu tiên chúng ta tạo sẽ là course.js trong thư mục models. File course.js: Đầu tiên chúng ta import mongoose và định nghĩa một schema 1234567891011121314151617import mongoose from &quot;mongoose&quot;;mongoose.Promise = global.Promise;const courseSchema = new mongoose.Schema(&#123; _id: mongoose.Schema.Types.ObjectId, title: &#123; type: String, required: true &#125;, description: &#123; type: String, required: true &#125;&#125;);export default mongoose.model(&quot;Course&quot;, courseSchema); 4. Tạo Controller Tạo một file course.js trong thư mục controllers Import mongoose và model course mà chúng ta export khi tạo model course. 12import mongoose from &quot;mongoose&quot;;import Course from &quot;../models/course&quot;; Tạo course: Đàu tiên chúng ta khởi tạo một Course với giá trị tương ứng với các key trong courseSchema. Sử dụng phương thức save() của mongoDB để lưu dữ liệu vào DB. Return một promise trả lại response cho client nếu save thành công và xử lý lỗi nếu có lỗi xảy ra. 1234567891011121314151617181920212223242526// create new causeexport function createCourse(req, res) &#123; const course = new Course(&#123; _id: mongoose.Types.ObjectId(), title: req.body.title, description: req.body.description &#125;); return course .save() .then(newCourse =&gt; &#123; return res.status(201).json(&#123; success: true, message: &quot;New cause created successfully&quot;, Course: newCourse &#125;); &#125;) .catch(error =&gt; &#123; console.log(error); res.status(500).json(&#123; success: false, message: &quot;Server error. Please try again.&quot;, error: error.message &#125;); &#125;);&#125; 5. Tạo route Tạo file main.js ở trong thư mục routes. 1234567import express from &quot;express&quot;;import &#123; createCourse &#125; from &quot;../controllers/course&quot;;const router = express.Router();router.post(&quot;/courses&quot;, createCourse);export default router; Lưu ý : Import express và createCourse từ controller Ở file app.js Chúng ta import route từ file main.js trong thư mục route. Thiết lập route với prefix là api 12345678// call in the installed dependencies...import logger from &#x27;morgan&#x27;;import mainRoutes from &#x27;./server/routes/main&#x27;;...// set up routeapp.use(&#x27;/api/&#x27;, mainRoutes);... 6. Testing với PostmanNhư vậy là ta đã tạo thành công một course mới và đã lưu đc vào MongoDB. 7. Get list course1. Controller File course.js trong thư mục controllers12345678910111213141516171819// Get all courseexport function getAllCourse(req, res) &#123; Course.find() .select(&quot;_id title description&quot;) .then(allCourse =&gt; &#123; return res.status(200).json(&#123; success: true, message: &quot;A list of all course&quot;, Course: allCourse &#125;); &#125;) .catch(err =&gt; &#123; res.status(500).json(&#123; success: false, message: &quot;Server error. Please try again.&quot;, error: err.message &#125;); &#125;);&#125; 2. Route File main.js trong thư mục route 123import &#123; createCourse, getAllCourse &#125; from &#x27;../controllers/course&#x27;;...router.get(&#x27;/courses&#x27;, getAllCourse); 3. Kết quả 8. Get single course1. Controller File course.js trong thư mục controllers12345678910111213141516171819// get single courseexport function getSingleCourse(req, res) &#123; const id = req.params.courseId; Course.findById(id) .then(singleCourse =&gt; &#123; res.status(200).json(&#123; success: true, message: `More on $&#123;singleCourse.title&#125;`, Course: singleCourse &#125;); &#125;) .catch(err =&gt; &#123; res.status(500).json(&#123; success: false, message: &quot;This course does not exist&quot;, error: err.message &#125;); &#125;);&#125; 2. Route File main.js trong thư mục route123import &#123; createCourse, getAllCourse, getSingleCourse &#125; from &#x27;../controllers/course&#x27;;...router.get(&#x27;/courses/:courseId&#x27;, getSingleCourse); 3. Kết quả 10. Delete course1. Controller File course.js trong thư mục controllers12345678910111213141516// delete a courseexport function deleteCourse(req, res) &#123; const id = req.params.courseId; Course.findByIdAndRemove(id) .exec() .then(() =&gt; res.status(204).json(&#123; success: true &#125;) ) .catch(err =&gt; res.status(500).json(&#123; success: false &#125;) );&#125; Lưu ý: Đối với update của mongoDB ta dùng toán tử $set 2. Route File main.js trong thư mục route 123import &#123; createCourse, getAllCourse, getSingleCourse, updateCourse, deleteCourse &#125; from &#x27;../controllers/course&#x27;;...router.delete(&#x27;/courses/:courseId&#x27;, deleteCourse); Kết luận Qua bài viết này chúng ta đã xây dựng thành công một ứng dụng web CRUD với nodejs, express, mongoDB, qua đó đồng thời hiểu về flow giữa 2 bên server và client. Mong bài viết hữu ích với mọi người và hẹn gặp mọi người ở bài viết tiếp theo về NodeJs. See ya! Nguồn tham khảo:https://medium.com/fbdevclagos/developing-basic-crud-operations-with-node-express-and-mongodb-e754acb9cc15","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://huongvnq.github.io/categories/NodeJS/"}],"tags":[{"name":"express","slug":"express","permalink":"https://huongvnq.github.io/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://huongvnq.github.io/tags/mongodb/"}]},{"title":"Models Trong Magento2","slug":"models-in-magento2","date":"2021-08-15T02:46:48.000Z","updated":"2021-08-20T09:17:19.000Z","comments":true,"path":"2021/08/15/models-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/08/15/models-in-magento2/","excerpt":"","text":"1. Lời mở đầu Như chúng ta đã biết, Model là một phần tử bắt buộc phải có khi tạo một ứng dụng CRUD. Model cũng là một phần quan trọng trong kiến trúc MVC (Model-View-Controller). Models trong Magento2 giúp chúng ta quản lý data, thao tác với database một cách dễ dàng hơn. Trong bài viết này chúng ta sẽ đi vào tìm hiểu về Models theo các phương diện Model, Resource Model, và Resource Model Collection. Let’s get started! 2. Tạo Database Table cho Model Để bắt đầu tìm hiểu, chúng ta hãy tạo một bảng trong database cho trực quan và dễ hiểu nhé. Để làm điều đó trong Magento2, chúng ta sẽ tạo một file setup:app/code/Learning/HelloWorld/Setup/InstallSchema.phpLưu ý: File InstallSChema chỉ được chạy một lần khi mà bạn Install Module (Xem thêm Create A New Module In Magento2) Nếu bạn đã Install Module trước đó thì phải phải nâng version của module lên và tạo bảng mới ở trong file UpgradeSchema.php. Chi tiết về các Database Script sẽ được mình trình bày cụ thể chi tiết trong bài viết sau nhé. hihi File: app/code/Learning/HelloWorld/Setup/InstallSchema.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?phpnamespace Learning\\HelloWorld\\Setup;class InstallSchema implements \\Magento\\Framework\\Setup\\InstallSchemaInterface&#123; public function install(\\Magento\\Framework\\Setup\\SchemaSetupInterface $setup, \\Magento\\Framework\\Setup\\ModuleContextInterface $context) &#123; $installer = $setup; $installer-&gt;startSetup(); if (!$installer-&gt;tableExists(&#x27;learning_helloworld_post&#x27;)) &#123; $table = $installer-&gt;getConnection()-&gt;newTable( $installer-&gt;getTable(&#x27;learning_helloworld_post&#x27;) ) -&gt;addColumn( &#x27;post_id&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_INTEGER, null, [ &#x27;identity&#x27; =&gt; true, &#x27;nullable&#x27; =&gt; false, &#x27;primary&#x27; =&gt; true, &#x27;unsigned&#x27; =&gt; true, ], &#x27;Post ID&#x27; ) -&gt;addColumn( &#x27;name&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TEXT, 255, [&#x27;nullable =&gt; false&#x27;], &#x27;Post Name&#x27; ) -&gt;addColumn( &#x27;url_key&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TEXT, 255, [], &#x27;Post URL Key&#x27; ) -&gt;addColumn( &#x27;post_content&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TEXT, &#x27;64k&#x27;, [], &#x27;Post Post Content&#x27; ) -&gt;addColumn( &#x27;tags&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TEXT, 255, [], &#x27;Post Tags&#x27; ) -&gt;addColumn( &#x27;status&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_INTEGER, 1, [], &#x27;Post Status&#x27; ) -&gt;addColumn( &#x27;featured_image&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TEXT, 255, [], &#x27;Post Featured Image&#x27; ) -&gt;addColumn( &#x27;created_at&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TIMESTAMP, null, [&#x27;nullable&#x27; =&gt; false, &#x27;default&#x27; =&gt; \\Magento\\Framework\\DB\\Ddl\\Table::TIMESTAMP_INIT], &#x27;Created At&#x27; )-&gt;addColumn( &#x27;updated_at&#x27;, \\Magento\\Framework\\DB\\Ddl\\Table::TYPE_TIMESTAMP, null, [&#x27;nullable&#x27; =&gt; false, &#x27;default&#x27; =&gt; \\Magento\\Framework\\DB\\Ddl\\Table::TIMESTAMP_INIT_UPDATE], &#x27;Updated At&#x27;) -&gt;setComment(&#x27;Post Table&#x27;); $installer-&gt;getConnection()-&gt;createTable($table); $installer-&gt;getConnection()-&gt;addIndex( $installer-&gt;getTable(&#x27;learning_helloworld_post&#x27;), $setup-&gt;getIdxName( $installer-&gt;getTable(&#x27;learning_helloworld_post&#x27;), [&#x27;name&#x27;, &#x27;url_key&#x27;, &#x27;post_content&#x27;, &#x27;tags&#x27;, &#x27;featured_image&#x27;], \\Magento\\Framework\\DB\\Adapter\\AdapterInterface::INDEX_TYPE_FULLTEXT ), [&#x27;name&#x27;, &#x27;url_key&#x27;, &#x27;post_content&#x27;, &#x27;tags&#x27;, &#x27;featured_image&#x27;], \\Magento\\Framework\\DB\\Adapter\\AdapterInterface::INDEX_TYPE_FULLTEXT ); &#125; $installer-&gt;endSetup(); &#125;&#125; Chạy command line để thực thi: 1php bin/magento setup:upgrade 2. Tạo Model Model là một phần quan trọng của kiến trúc MVC Là một class đại diện cho một thực thể hay một bảng trong CSDL Trong Magento2, Models có rất nhiều chức năng, như quản lý thao tác database, install, upgrade module. Trong ví dụ này chúng ta sẽ nói về chức năng quản lý thao tác data của Models và cụ thể là bảng learning_helloworld_post mà chúng ta vừa tạo ở bên trên. Tạo file model: app/code/Mageplaza/HelloWorld/Model/Post.php 123456789101112131415161718192021222324252627&lt;?phpnamespace Learning\\HelloWorld\\Model;class Post extends \\Magento\\Framework\\Model\\AbstractModel implements \\Magento\\Framework\\DataObject\\IdentityInterface&#123; const CACHE_TAG = &#x27;learning_helloworld_post&#x27;; protected $_cacheTag = &#x27;learning_helloworld_post&#x27;; protected $_eventPrefix = &#x27;learning_helloworld_post&#x27;; protected function _construct() &#123; $this-&gt;_init(&#x27;Learning\\HelloWorld\\Model\\ResourceModel\\Post&#x27;); &#125; public function getIdentities() &#123; return [self::CACHE_TAG . &#x27;_&#x27; . $this-&gt;getId()]; &#125; public function getDefaultValues() &#123; $values = []; return $values; &#125;&#125; Tất cả Model sẽ được extends \\Magento\\Framework\\Model\\AbstractModel và implements \\Magento\\Framework\\DataObject\\IdentityInterface Class Model phải định nghĩa phương thức getIdentities() trả về một id duy nhất định danh cho Model Phương thức _construct() sẽ được gọi mỗi khi Model được khởi tạo. Phương thức _construct() sẽ gọi đến phương thức _init() chỉ định Resource Model nào dùng để fetch data từ database. Ở đây là resource model Learning\\HelloWorld\\Model\\ResourceModel\\Post. Ngoài ra thì ở class Model còn định nghĩa một vài cái biến, nhưng thôi chúng ta tạm thời bỏ qua trong bài viết này :D 3. Tạo Resource Model Model chưa tất cả các logic thao tác với database. Tuy nhiên nó sẽ không trực tiếp thực thi các câu truy vấn SQL. Thay vào đó Resource Model sẽ làm việc này. Chúng ta sẽ tạo Resource Model app/code/Learning/HelloWorld/Model/ResourceModel/Post 1234567891011121314151617181920&lt;?phpnamespace Learning\\HelloWorld\\Model\\ResourceModel;class Post extends \\Magento\\Framework\\Model\\ResourceModel\\Db\\AbstractDb&#123; public function __construct( \\Magento\\Framework\\Model\\ResourceModel\\Db\\Context $context ) &#123; parent::__construct($context); &#125; protected function _construct() &#123; $this-&gt;_init(&#x27;learning_helloworld_post&#x27;, &#x27;post_id&#x27;); &#125;&#125; Tất cả Resource Model trong Magento2 sẽ phải extends abstract class \\Magento\\Framework\\Model\\ResourceModel\\Db\\AbstractDb, class này chứa tất cả các function để thao tác với CSDL. Cũng giống như Model class, Resource Model class cũng phải có phương thức _construct(), phương thức này gọi đến _init() để định nghĩa bảng csdl và khóa chính của bảng đó, ở đây là mageplaza_helloworld_post và khóa chínhpost_id 4. Tạo Resource Model Collection Collection cho phép chúng ta lấy ra hay lọc một collection dữ liệu của một bảng. Collection Model được đặt ở app/code/Learning/HelloWorld/Model/ResourceModel/Post/Collection.php 1234567891011121314151617181920&lt;?phpnamespace Learning\\HelloWorld\\Model\\ResourceModel\\Post;class Collection extends \\Magento\\Framework\\Model\\ResourceModel\\Db\\Collection\\AbstractCollection&#123; protected $_idFieldName = &#x27;post_id&#x27;; protected $_eventPrefix = &#x27;learning_helloworld_post_collection&#x27;; protected $_eventObject = &#x27;post_collection&#x27;; /** * Define resource model * * @return void */ protected function _construct() &#123; $this-&gt;_init(&#x27;Learning\\HelloWorld\\Model\\Post&#x27;, &#x27;Learning\\HelloWorld\\Model\\ResourceModel\\Post&#x27;); &#125;&#125; Một Collection Class phải được extends \\Magento\\Framework\\Model\\ResourceModel\\Db\\Collection\\AbstractCollection _construct() gọi đến _init() chỉ định Model và Resource Model Class. 5. Factory Object Vất vả từ đầu đến giờ,chúng ta đã tạo được bảng trong CSDL, Model và Resource Model Class. Vậy làm sao để sử dụng nó bây giờ nhỉ? Hihi, Sắp xong rồi Trong OPP, chắc các bạn cũng đã quen với khái niệm Factory dùng để khởi tạo một object. Trong Magento, Factory cũng được sử dụng như vậy :) Tên của Factory Class sẽ là tên của Class mà bạn muốn khởi tạo (Model Class, Resource Model Class, hoặc Resource Model Collection Class) nối với từ Factory, ví dụ class PostFactory. Bạn không phải tạo class này đâu vì Magento sẽ tạo nó cho bạn. Bất kể khi nào Magento gặp một class có tên kết thúc bằng Factory, Magento sẽ tự động generate class Factory đó ở thư mục var/generation nếu class đó chưa tồn tạiỞ ví dụ của chúng ta, bạn có thể tìm thấy class Factory ởvar/generation/Learning/HelloWorld/Model/PostFactory.php Giả sử để khởi tạo một Model object, chúng ta sẽ sử dụng dependency injection để inject một factory object vào contructor, sau đó sử dụng factory object để khởi tạo model object. Ví dụ dưới đây, trong hàm controller chúng ta sẽ gọi Model để lấy ra data File app/code/Learning/HelloWorld/Controller/Index/Index.php 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Learning\\HelloWorld\\Controller\\Index;class Index extends \\Magento\\Framework\\App\\Action\\Action&#123; protected $_pageFactory; protected $_postFactory; public function __construct( \\Magento\\Framework\\App\\Action\\Context $context, \\Magento\\Framework\\View\\Result\\PageFactory $pageFactory, \\Learning\\HelloWorld\\Model\\PostFactory $postFactory ) &#123; $this-&gt;_pageFactory = $pageFactory; $this-&gt;_postFactory = $postFactory; return parent::__construct($context); &#125; public function execute() &#123; $post = $this-&gt;_postFactory-&gt;create(); $collection = $post-&gt;getCollection(); foreach($collection as $item)&#123; echo &quot;&lt;pre&gt;&quot;; print_r($item-&gt;getData()); echo &quot;&lt;/pre&gt;&quot;; &#125; exit(); return $this-&gt;_pageFactory-&gt;create(); &#125;&#125; Chúng ta có thể thấy, PostFactory sẽ được inject ở trong hàm __construct(), và ở hàm execute chúng ta thực hiện$post = $this-&gt;_postFactory-&gt;create(); Lưu ý: Ở ví dụ bên trên chúng ta lấy ra collection từ Model Object bằng phương thức $collection = $post-&gt;getCollection(); Nếu bạn gặp phải vấn đề phương thức getCollection() đã bị Deprecated thì một trong những cách khác bạn có thể sử dụng đó là dùng Collection Factory Class của Resource Model nhé 12345678910111213protected $_postCollectionFactory;public function __construct( \\Learning\\HelloWorld\\Model\\ResourceModel\\Post\\CollectionFactory $postCollectionFactory)&#123; ... $this-&gt;_postCollectionFactory = $postCollectionFactory; ...&#125;$collection = $this-&gt;_postCollectionFactory-&gt;create(); Xong rồi, bây giờ bạn hãy thêm bản ghi vào CSDL và mở trình duyệt test thử controller index nhé 1http://&lt;yourhost.com&gt;/helloworld/index/index 6. Kết luận Bài viết mình đến đây là hết rồi, mong bài viết sẽ mang cho bạn những kiến thức cơ bản về Model trong Magento2, một phần quan không thể thiếu trong một ứng dụng CRUD. Cùng đón chờ những bài viết tiếp tiếp theo của mình về Magento2 nhé. See ya! Bài viết tham khảo: https://www.mageplaza.com/magento-2-module-development/how-to-create-crud-model-magento-2.html","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Routing Trong Magento2","slug":"routing-in-magento2","date":"2021-07-20T05:05:37.000Z","updated":"2021-07-25T03:07:18.010Z","comments":true,"path":"2021/07/20/routing-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/07/20/routing-in-magento2/","excerpt":"","text":"1.Lời mở đầu Routing là một trong những phần rất quan trọng trong luồng hoạt động của Magento2. Routing sẽ chịu trách nhiệm xử lý URL request, từ URL sẽ chỉ ra module nào chịu trách nhiệm xử lý request và thực thi controller action. Trong bài viết này, chúng ta sẽ cùng đi tìm hiểu cách mà router sẽ “match” với controller action như thế nào. Sau đó sẽ tìm hiểu cách tạo một custom router. Hãy cùng đi vào nội dung của bài viết thôi nào :smile: 2.Magento2 Request Flow Trong Magento2, một request URL sẽ như thế này1http://example.com/index.php/front_name/controller/action Trong url trên, front_name sẽ được dùng để chỉ định module. Router sẽ định nghĩa cái tên này cho mỗi module trong file routes.xml Khi bạn tạo một request trong Magento2, Magento2 sẽ xử lý theo luồng như sau FrontController sẽ được gọi đến trong class Http để điều hướng request.Chúng ta hãy cùng xem File vendor/magento/framework/App/FrontController.php12345678910111213141516171819202122232425262728293031323334public function dispatch(RequestInterface $request)&#123; \\Magento\\Framework\\Profiler::start(&#x27;routers_match&#x27;); $routingCycleCounter = 0; $result = null; while (!$request-&gt;isDispatched() &amp;&amp; $routingCycleCounter++ &lt; 100) &#123; /** @var \\Magento\\Framework\\App\\RouterInterface $router */ foreach ($this-&gt;_routerList as $router) &#123; try &#123; $actionInstance = $router-&gt;match($request); if ($actionInstance) &#123; $request-&gt;setDispatched(true); $this-&gt;response-&gt;setNoCacheHeaders(); if ($actionInstance instanceof \\Magento\\Framework\\App\\Action\\AbstractAction) &#123; $result = $actionInstance-&gt;dispatch($request); &#125; else &#123; $result = $actionInstance-&gt;execute(); &#125; break; &#125; &#125; catch (\\Magento\\Framework\\Exception\\NotFoundException $e) &#123; $request-&gt;initForward(); $request-&gt;setActionName(&#x27;noroute&#x27;); $request-&gt;setDispatched(false); break; &#125; &#125; &#125; \\Magento\\Framework\\Profiler::stop(&#x27;routers_match&#x27;); if ($routingCycleCounter &gt; 100) &#123; throw new \\LogicException(&#x27;Front controller reached 100 router match iterations&#x27;); &#125; return $result;&#125; Chúng ta có thể thấy ở hàm dispatch, router list sẽ được cho vào vòng lặp để tìm kiếm router nào sẽ match với request. Khi tìm ra controller action nào “match” với request, action đó sẽ được gọi và thực thi. 3.Tạo một custom route trong area Frontend Trước khi đi vào tạo một route, chúng ta hãy tạo một module, tham khảo bài viết Create A New Module In Magento2 Ở đây mình tạo Module là Learning_Routing Để đăng kí một frontend route, chúng ta phải tạo file routes.xmlFile app/code/Learning/Routing/etc/frontend/routes.xml 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;!--Use router &#x27;standard&#x27; for frontend route--&gt; &lt;router id=&quot;standard&quot;&gt; &lt;!--Define a custom route with id and frontName--&gt; &lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt; &lt;!--The module which this route match to--&gt; &lt;module name=&quot;Learning_Routing&quot;/&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Thật đơn giản để đăng kí một route. Ở đây ta phải sử dụng standard router cho area Frontend. Route này sẽ có một route con định nghĩa module cho nó và 2 attribute: Attribute id là một chuỗi unique định danh một route. Chúng ta cũng sẽ sử dụng chuỗi này để khai báo layout cho action của module. Attribute frontName cũng là một chuỗi unique, chuỗi này được chỉ định trong url. Ví dụ nếu bạn khai báo một route như sau 1&lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt; Thì Url sẽ là 1http://example.com/index.php/helloworld/controller/action Layout cho action này sẽ là 1helloworld_controller_action.xml Và chúng ta phải tạo controller action ở trong thư mục 1&#123;namespace&#125;/&#123;module&#125;/Controller/&#123;Controller&#125;/&#123;Action&#125;.php 4. Tạo một custom route trong area Admin (Admin Route) Route này tương tự như route cho Frontend chỉ khác là chúng ta sẽ khai báo nó trong thư mục adminhtml và với router id là admin File app/code/Learning/Routing/etc/adminhtml/routes.xml 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;!--Use router &#x27;admin&#x27; for admin route --&gt; &lt;router id=&quot;admin&quot;&gt; &lt;!--Define a custom route with id and frontName --&gt; &lt;route id=&quot;learning_routing&quot; frontName=&quot;learning_routing&quot;&gt; &lt;!--The module which this route match to--&gt; &lt;module name=&quot;Learning_Routing&quot;/&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Một URL của một admin page sẽ có cấu trúc tương tự như đối với frontend page, tuy nhiên admin_area sẽ được thêm vào ở đằng trước frontName để chỉ định đây là một route của area Admin.Ví dụ url của một admin csm page 1http://example.com/index.php/admin/learning_routing/controller/action Controller Action cho admin page cũng sẽ được thêm vào bên trong thư mục Controller/Adminhtml 1&#123;namespace&#125;/&#123;module&#125;/Controller/Adminhtml/&#123;Controller&#125;/&#123;Action&#125;.php 5. Cách sử dụng route để ghì đè controller của core Như chúng ta đã thấy ở những phần bên trên, mỗi route sẽ có một id để định danh. Vậy điều gì sẽ xảy ra nếu chúng ta định nghĩa 2 route với cùng một id? Câu trả lời là action controller sẽ tìm thấy ở cả 2 modules. Và chúng ta phải sử dụng attribute before/after để config thứ tự module, chỉ định module nào sẽ được tìm thấy trước. Ví dụ, nếu mà chúng ta muốn ghi đè controller customer/account/login chúng ta sẽ định route trong route.xml như thế này:1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;!--Use router &#x27;standard&#x27; for frontend route--&gt; &lt;router id=&quot;standard&quot;&gt; &lt;!--Define a custom route with id and frontName--&gt; &lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt; &lt;!--The module which this route match to--&gt; &lt;module name=&quot;Learning_Routing&quot;/&gt; &lt;/route&gt; &lt;route id=&quot;customer&quot;&gt; &lt;module name=&quot;Learning_Routing&quot; before=&quot;Magento_Customer&quot; /&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Sau đó định nghĩa một file controller :app/code/Learning/Routing/Controller/Account/Login.php Khi đó, FrontController sẽ tìm thấy action Login ở trong Module Learning_Routing trước, action này sẽ được chạy và action Login của Magento_Customer sẽ không được chạy nữa. Như vậy là chúng ta đã thực hiện ghi đè Controller thành công. 6. Tổng kết Route là một phần cơ bản mà chúng ta phải biết khi tìm hiểu về luồng hoạt động của Magento. Qua bài viết này mong các bạn sẽ nắm được cách hoạt động của một route và đặc biệt là các quy tắc đặt tên để Magento có thể nhận biết và xử lý. Cảm ơn các bạn đã đọc đến cuối bài viết và hẹn gặp lại các bạn trong các bài viết tiếp theo của serries Tìm hiểu về Magento. :kissing_heart: Nguồn tham khảo: https://www.mageplaza.com/magento-2-module-development/magento-2-routing.html","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Create A New Module In Magento2","slug":"create-a-new-module-in-magento2","date":"2021-07-18T03:55:23.000Z","updated":"2021-07-25T03:21:59.354Z","comments":true,"path":"2021/07/18/create-a-new-module-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/07/18/create-a-new-module-in-magento2/","excerpt":"","text":"1.Tổng quát Module là một đơn vị cấu trúc của Magento. Toàn bộ hệ thống sẽ được xây dựng dựa trên các Module. Thông thường, bước đầu tiên để custom core của mangeto cũng là tạo module. Để tạo một module, chúng ta phải thực hiện các bước sau: Tạo một thư mục module Tạo file etc/module.xml Tạo file registration.php Chạy script bin/magento setup:upgrade để install module mới Kiểm tra module được active hay chưa. chúng ta hãy cùng đi vào cụ thể từng bước nhé. 2. Tạo thư mục cho module Chúng ta có 2 nơi để tạo thư mục cho module. Đó là trong folder app/code và trong folder vendor. Tuỳ thuộc vào cách cài đặt Magento2, những module core của magento có thể được đặt trong các thư mục vendor/magento/magento-* (trường hợp dùng composer để install) hoặc app/code/Magento/ (trường hợp clone Github) Vậy chúng ta nên đặt module mới ở đâu? Nếu chúng ta build một module cho một project cụ thể, chúng ta sẽ tạo mới module ở trong thư mục app/code và commit lên repository của product trên Github. Nếu chúng ta xây dựng một extension để tái sử dụng, chúng ta sẽ dùng composer để tạo nó và chúng ta sẽ đặt module ở trong vendor/&lt;YOUR_VENDOR&gt;/module-something Tên của module trong magento2 sẽ bao gồm 2 phần: tên vendor và tên của chính module đó. Nói cách khác, module sẽ được nhóm lại thành 1 vendor do vậy khi đặt tên của module ta phải chỉ định cả tên vendor đó. Trong ví dụ này chúng ta sẽ tạo một vendor là Learning và một module là First Unit cd to folder root mkdir app/code/Learning mkdir app/code/Learning/FirstUnit 3. Tạo file etc/module.xml Trước tiên chúng ta phải đảm bảo rằng chúng ta có quyền để tạo file và folder trong folder root nhé. Nếu đã có quyền, chúng ta tạo một file etc/module.xml. Phải có file này thì module mới tồn tại được. File module.xml chứa các thông tin sau Module name Module version Dependencies Module name đã được định nghĩa bằng tên thư mục mà chúng ta vừa tạo. Trong Magento2, tất cả các class name phải tuân theo cấu trúc thư mục. Bởi vì chúng ta tạo thư mục là Learning/FirstUnit nên module name của chúng ta sẽ là Learning_FirstUnit. Tất cả các class thuộc module này sẽ là bắt đầu với Learning/FirstUnitVí dụ Learning\\FirstUnit\\Observer\\Test Tiếp theo đến Module version. Module version cho biết được phiên bản hiện tại của database schema và data, được sử dụng cho việc upgrade module. Ví dụ như giả định bạn muốn thay đổi cấu trúc bảng dữ liệu (database table schema) của module này. Làm thế nào để bạn đảm bảo rằng thay đổi này sẽ được áp dụng trên tất cả các phiên bản mã code đã được deploy rồi. Magento sẽ có các script install và upgrade cho mỗi module (Hoặc bạn tự tạo). Các file script này sẽ có các command để thay đổi database schema và data. Để theo dõi xem liệu đã thực thi phần lệnh trong script hay chưa, magento sẽ track dựa vào module version. Mỗi lần bạn thực thi thay đổi mới trong database, bạn sẽ phải thực thi với version mới của module và tăng version của module lên tương ứng trong file module.xml. Magento sẽ lưu phiên bản hiện tại của module trong database. Nếu giá trị trong database và trong file module.xml không khớp với nhau, nó sẽ thực thi upgrade code. Dependencies: Nếu một module phụ thuộc vào một module khác thì chúng ta phải khai báo trong file modules.xml danh sách các module mà module hiện tại của chúng ta đang phụ thuộc vào. Ví dụ, module này chúng ta tạo ra sẽ phụ thuộc vào module Magento_Catalog. Đầu tiên chúng ta tạo folder etc:mkdir app/code/Learning/FirstUnit/etc Tạo file module.xmll12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:Module/etc/module.xsd&quot;&gt; &lt;module name=&quot;Learning_FirstUnit&quot; setup_version=&quot;0.0.1&quot;&gt; &lt;sequence&gt; &lt;module name=&quot;Magento_Catalog&quot;/&gt; &lt;/sequence&gt; &lt;/module&gt;&lt;/config&gt; Trong file module mà chúng ta vừa tạo, chúng ta đã chỉ định: Module name: Learning_FirstUnit dựa trên folder mà chúng ta đã tạo. Versionn: 0.0.1 (Version khởi tạo của module) Dependency: Magento_Catalog. Chúng ta có thể có nhiều Dependency, khi ấy chúng ta hãy liệt kê bằng các thẻ &lt;module name=&quot;...&quot; /&gt; ở bên trong thẻ &lt;sequence&gt; 4. Tạo file registration.php Mỗi module sẽ phải có file này để đăng kí cho magento biết vị trí của module. Tiếp tục example, chúng ta sẽ tạo file app/code/Learning/FirstUnit/registration.php1234&lt;?php \\Magento\\Framework\\Component\\ComponentRegistrar::register(\\Magento\\Framework\\Component\\ComponentRegistrar::MODULE, &#x27;Learning_FirstUnit&#x27;,__DIR__); File registrationn.phpp sẽ giống nhau đối với tất cả các module, chỉ khác tên của module, ở đây của chúng ta là Learning_FirstUnit 5. Chạy command Tạo xong module chúng ta phải chạy command để active module, để thông báo cho magento biết về sự hiện diện của nó.1$ php bin/magento setup:upgrade Câu lệnh sẽ cho ra rất nhiều dòng input, hãy check xem một trong các dòng đó có Learning_FirstUnit hay không. 6 Check module is active Mặc dù chúng ta chưa add những logic code vào module, trong ví dụ này chúng ta chỉ thực hiện tạo module, module hiện taị đang trống và không thể nhìn thấy được. Để kiểm tra module đã được nhận hay chưa, chúng ta hãy kiểm tra file app/etc/config.php, file này chứa tất cả các module đã được active. Chúng cũng không được thay đổi file này một cách thủ công. Check module is active 1$ grep Learning_FirstUnit app/etc/config.php 7. Kết luận. Lại là một bài viết đơn giản siêu siêu beginer cho các bạn mới mày mò tìm hiểu magento, thực hiện các bước trong bài viết, các bạn đã có thể tạo cho mình một module để bắt đầu có thể add những logic phực tạp hơn cho module trong magento. Mong bài viết sẽ có ích đối với các bạn và hãy đón chờ các bài viết tiếp theo của mình trong serries về Magento nhé. Ciao! Bài viết tham khảo https://devdocs.magento.com/videos/fundamentals/create-a-new-module/","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Create A New Page In Magento2","slug":"create-a-new-page-in-magento2","date":"2021-07-17T07:06:27.037Z","updated":"2021-08-15T02:42:07.962Z","comments":true,"path":"2021/07/17/create-a-new-page-in-magento2/","link":"","permalink":"https://huongvnq.github.io/2021/07/17/create-a-new-page-in-magento2/","excerpt":"","text":"1. Tổng quan Mở đầu series chia sẻ về Magento lần này, mình sẽ trình bày cách tạo một page mới trong magnento. Chúng ta sẽ cùng tạo một page mới trả về JSON với một tham số “HELLO WORLD!” nhé. :D Để thêm một page mới trong magento2, chúng ta phải tạo một controller. Trong Magento2, một controller là một file được đặt ở một nơi được quy định để magento có thể hiểu và response một route tương ứng. Một route trong Magento2 là một URL tiêu chuẩn bao gồm 3 phần: frontName controllerName actionName Chúng ta sẽ cùng đi vào tìm hiểu xem Magento dựa vào 3 phần này như thế nào để tương ứng với một file nhất định. Các bước để tạo một new page: Tạo một module mới. Tạo file routes.xml Tạo file controller (action) Chúng ta hãy cùng đi vào cụ thể từng bước nhé. :D 2. Tạo một module mới Để tạo một module, bạn cần làm theo các bước sau: Tạo một folder cho module. Tạo file etc/module.xml Tạo file registration.php Chạy lệnh bin/magento setup:upgrade Thực hành luôn, chúng ta sẽ tạo một thư mực module tên là Learning_HelloPage123$ cd &lt;magento2_root&gt;/app/code$ mkdir Learning$ mkdir Learning/HelloPage Tạo file registration.php123456&lt;?php /*** Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.*/\\Magento\\Framework\\Component\\ComponentRegistrar::register( \\Magento\\Framework\\Component\\ComponentRegistrar::MODULE, &#x27;Learning_HelloPage&#x27;,__DIR__); Tạo file module.xml12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--/*** Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.*/--&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:Module/etc/module.xsd&quot;&gt; &lt;module name=&quot;Learning_HelloPage&quot; setup_version=&quot;0.0.1&quot;&gt; &lt;/module&gt;&lt;/config&gt; Như vậy là chúng ta đã tạo xong một module mới. Về Quy tắc đặt tên, cấu trúc thư mục, ý nghĩa của các file registration.php, module.xml mình sẽ trình bày cụ thể trong bài viết tiếp theo. 3. Tạo file routes.xml Trước khi đi vào tạo file routes.xml, chúng ta hãy cùng tìm hiểu xem một route hoạt động thế nào trong magento2 nhé. Magento có các area, chẳng hạn như admin - liên quan đến việc hiện thị bên trang admin, frontend liên quan đến việc hiện thị giao diện phía người dùng. Mỗi một area sẽ có một file routes.xml được merge từ các file etc/area/routes.xml từ tất cả các module. File route.xml sẽ chứa tất cả các thông tin về route đựợc đăng kí và frontName. Lưu ý rằng frontName sẽ là phần đầu của một route. Để dễ hiểu hơn chúng ta hãy đi vào thực hành nhé. Bởi vì chúng ta đang tạo một page return về JSON cho user, tức là đang trong frontend area. Do đó chúng ta sẽ tạo một file ect/frontend/routes.xml cho module Learning_HelloPage12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--/*** Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.*/--&gt;&lt;config xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;urn:magento:framework:App/etc/routes.xsd&quot;&gt; &lt;router id=&quot;standard&quot;&gt; &lt;route id=&quot;learning&quot; frontName=&quot;test&quot;&gt; &lt;module name=&quot;Learning_HelloPage&quot; /&gt; &lt;/route&gt; &lt;/router&gt;&lt;/config&gt; Chúng ta vừa thêm một route tên là learning.Lưu ý là tên của route không nhất thiết phải trùng với tên của module. frontName mà chúng ta tạo lfa test. Thông thường tên route và frontName là giống nhau nhưng cũng không bắt buộc phải vậy. Khi magento xử lý một route test/chunk2/chunk3, magento sẽ kiểm tra liệu trong thư mục module Learning_HelloPage có thư mục Controller/Chunk2 hay không. Tiếp đến trong thư mục Chunk2 có action file Chunk3 hay không. Ở đây route của chúng ta sẽ là test/page/view. Chúng ta hãy cùng tạo file Controller để magento có thể hiểu và lấy làm file xử lý route này nhé. 4. Tạo file controller (file action) Như đã nó ở bên trên, với route test/page/view, Magento sẽ tìm đến thư mục Controller/Page, tiếp đó tìm đến file View.php Chúng ta thêm controller như sau: 123$ cd &lt;magento2_root&gt;/app/code/Learning/HelloPage$ mkdir Controller$ mkdir Controller/Page Tạo action file Controller/Page/View.php: 12345678910111213141516171819202122232425262728293031323334&lt;?php /** * Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details. */namespace Learning\\HelloPage\\Controller\\Page;class View extends \\Magento\\Framework\\App\\Action\\Action&#123; /** * @var \\Magento\\Framework\\Controller\\Result\\JsonFactory */ protected $resultJsonFactory; /** * @param \\Magento\\Framework\\App\\Action\\Context $context * @param \\Magento\\Framework\\Controller\\Result\\JsonFactory $resultJsonFactory */ public function __construct( \\Magento\\Framework\\App\\Action\\Context $context, \\Magento\\Framework\\Controller\\Result\\JsonFactory $resultJsonFactory)&#123; $this-&gt;resultJsonFactory = $resultJsonFactory; parent::__construct($context);&#125; /** * View page action * * @return \\Magento\\Framework\\Controller\\ResultInterface */ public function execute() &#123; $result = $this-&gt;resultJsonFactory-&gt;create(); $data = [&#x27;message&#x27; =&gt; &#x27;Hello world!&#x27;];return $result-&gt;setData($data);&#125; &#125; Việc còn lại là active module và page của chúng ta bằng cách chạy câu lệnh Magento setup uprade 12$ cd &lt;magento2_root&gt;$ php bin/magento setup:upgrade Đến đây chúng ta có thể test page của chúng ta bằng cách gõ đường link /test/page/view. Chúng ta sẽ nhìn thấy message hiện lên trên trang 1&#123; &quot;message&quot;: &quot;Hello world!&quot; &#125; Ở bài viết này chủ yếu đi vào cách tạo một page mới nên chúng ta xây dựng một trang trả về một ResultJson. Ngoài ra magento2 có rất nhiều kiểu Result Object cho các trừờng hợp khác như ResultPage, Forward Result… 5. Tổng kết. Bài viết là một bài cơ bản, đơn giản về cách tạo một page trong Magento2. Mong bài viết sẽ hữu ích cho các bạn beginner bắt đầu mày mò nghiên cứu về magento. Mình cũng mới dấn thân vào con đường Magento nên mong các bạn góp ý cho bài viết và hãy cùng mình học tập tìm hiểu về magento trong những bài viết tiếp theo nhé. see ya! Bài viết tham khảo https://devdocs.magento.com/videos/fundamentals/create-a-new-page/","categories":[{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"}],"tags":[{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"}]},{"title":"Thực thi truy vấn GraphQL trên Server","slug":"graphql-server-execution","date":"2021-04-21T04:46:57.000Z","updated":"2021-07-23T04:49:06.127Z","comments":true,"path":"2021/04/21/graphql-server-execution/","link":"","permalink":"https://huongvnq.github.io/2021/04/21/graphql-server-execution/","excerpt":"","text":"1. Giới thiệu chung Khi Client gọi các câu truy vấn GraphQL, các câu truy vấn này sẽ trải qua quá trình validation dựa vào Type System (Schema). Nếu câu truy vấn là hợp lệ, nó sẽ được thực thi bởi GraphQL Server, sau đó server sẽ trả về kết quả mang “hình dáng” của câu query mà Client yêu cầu, kết quả trả về là kiểu Json. GraphQL không thể thực thi Query mà không có Schema. Chúng ta hãy cùng sử dụng ví dụ Schema sau để minh họa việc thực thi một truy vấn. 1234567891011121314151617181920type Query &#123; human(id: ID!): Human&#125;type Human &#123; name: String appearsIn: [Episode] starships: [Starship]&#125;enum Episode &#123; NEWHOPE EMPIRE JEDI&#125;type Starship &#123; name: String&#125; Để mô tả điều gì xảy ra khi một query được thực thi, chúng ta hãy thực hiện một câu query phía client như sau 123456789&#123; human(id: 1002) &#123; name appearsIn starships &#123; name &#125; &#125;&#125; Kết quả server trả về như sau 12345678910111213141516&#123; &quot;data&quot;: &#123; &quot;human&quot;: &#123; &quot;name&quot;: &quot;Han Solo&quot;, &quot;appearsIn&quot;: [&quot;NEWHOPE&quot;, &quot;EMPIRE&quot;, &quot;JEDI&quot;], &quot;starships&quot;: [ &#123; &quot;name&quot;: &quot;Millenium Falcon&quot; &#125;, &#123; &quot;name&quot;: &quot;Imperial shuttle&quot; &#125; ] &#125; &#125;&#125; Mỗi một trường trong query như là một function hay method của type cha để trả về type con. Chẳng hạn như name là một function của type human để trả về type name của human. Mỗi field trên mỗi type có một function chịu trách nhiệm xử lý phía backend gọi là resolver. Khi một field được thực thi, resolver tương ứng sẽ được gọi để trả về value cho các filed con tiếp theo. Nếu một field là một loại scalar như là một string hay một number, thì việc thực thi hoàn thành. Còn nếu một field trả về một object value, thì việc thực thi sẽ lại được tiếp tục trên các field của object đó, cứ tiếp tục như vậy cho đến khi đạt được các scalar value. GraphQL Query luôn luôn kết thúc ở các scalar value. 2. Root fields &amp; Resolvers Ở level cao nhất của một GraphQL Server chính là Root type hay còn gọi Query type, nó đại diện cho các entry point của GraphQL API. Ở ví dụ dưới đây, Query type định nghĩa một field human nhận vào tham số là id. Trên server, định nghĩa một function resolver cho field human này, function này đại khái sẽ truy xuất database lấy ra dữ liệu, khởi tạo và trả về một đối tượng Human1234567Query: &#123; human(obj, args, context, info) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) &#125;&#125; Ví dụ bên trên được viết với ngôn ngữ JavaScript, tuy nhiên bạn có thể xây dựng một GraphQL Server bằng nhiều ngôn ngữ khác. Tuy nhiên dù thế nào thì một resolver function sẽ nhận vào 4 tham số obj: Đối tượng trả về từ field cha. args: Một object chứa tất cả các tham số GraphQL cung cấp cho field này. context: Một object chia sẻ giữa tất cả các resolver bao gồm các thông tin liên quan đến ngữ cảnh như thông tin người dùng đăng nhập, kết nối cơ sở dữ liệu … info 3. Trivial Resolvers (Những hàm resolver “easy to solve”) Khi object Human được trả về cho trường human, GraphQL sẽ thực thi tiếp cho những field là field con của field human12345Human: &#123; name(obj, args, context, info) &#123; return obj.name &#125;&#125; GraphQL mạnh mẽ với hệ thống type system được định nghĩa trước, được sử dụng để GraphQL quyết định cái gì làm tiếp theo. Thậm chí, trước cả khi human field return bất cứ cái gì, GraphQL cũng biết bước tiếp theo là resolve những field của Human bởi vì type system sẽ nói cho GraphQL biết rằng fielđ human sẽ trả về Human Việc giải quyết cho trường name trong ví dụ bên trước rất là đơn giản, rõ ràng. Function resolver cho trường name được gọi, ở đây obj chính là object new Human trả về từ field đằng trước (field cha, field human). Function sẽ chả về trường name truy vấn trên đối tượng obj Lưu ý : Trong thực tế nhiều thư viện GraphQL sẽ bỏ đi những hàm resolver đơn giản như trên. Nếu hàm resolver được chỉ đinh, GraphQL sẽ thực thi hàm resolver đó, nếu không thì GraphQL sẽ ngầm hiểu để đọc và trả về một trường cùng tên (cụ thể trong ví dụ trên, GraphQL sẽ ngầm hiểu và trả về trường name của object Human cho field name là field con của field Human). 4. Scalar coercion (cưỡng chế vô hướng) Trong khi field name được resolve, thì các field appearsIn và starships cũng được thực thi đồng thời. Hàm thực thi của field appearsIn có thể cũng là một hàm trivival resolver12345Human: &#123; appearsIn(obj) &#123; return obj.appearsIn // returns [ 4, 5, 6 ] &#125;&#125; Ở đây chú ý rằng, type system đã yêu cầu appearsIn phải trả về kiểu Enum Episode. Tuy nhiên function resolver lại return về numbers! Điều hay ho ở đây là chúng ta hãy xem lại kết quả trả về cho client đã được show ở phần đầu của bài viết, chúng ta sẽ thấy kết quả trả về sẽ tương ứng với các giá trị của Enum Đây là một ví dụ về Scalar Coercion. Type System sẽ dựa vào schema để biết được cái gì được mong đợi trả về và sẽ convert giá trị trả về bởi resolver để phù hợp với “hợp đồng” 5. Kết quả trả về cho client. Khi mỗi field được resolve, kết quả sẽ được trả về theo định dạng key-value. Key là tên field hoặc alias, value là giá trị trả về của resolver Kết quả sẽ theo đúng cấu trúc mà client yêu cầu trong truy vấn truyền lên. 6. Kết luận Ở bài viết này mình đã trình bày tổng quan về các mà GraphQL server thực hiện để đáp ứng yêu cầu phía Client. Nói chung GraphQL Server phải định nghĩa các hàm resolver để xử lý trả về dữ liệu cho các field (từ Root field đến các field con) Mong bài viết sẽ truyền đạt được nội dung một cách ngắn gọn nhất đến các bạn và mong nhận được góp ý nếu có chỗ nào chưa chính xác. Nguồn tham khảo https://graphql.org/learn/execution/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"resolve","slug":"resolve","permalink":"https://huongvnq.github.io/tags/resolve/"}]},{"title":"GraphQL Fragment","slug":"graphql-fragment","date":"2021-03-20T04:40:46.000Z","updated":"2021-07-23T04:45:33.600Z","comments":true,"path":"2021/03/20/graphql-fragment/","link":"","permalink":"https://huongvnq.github.io/2021/03/20/graphql-fragment/","excerpt":"","text":"1. Fragment trong GraphQL là gì? Trong GraphQL có một khái niệm hay được sử dụng là Fragment. Trong bài viết ngày hôm nay chúng ta hãy cùng đi tìm hiểu khái niệm này là như thế nào nhé. Một GraphQL Fragment là một phần tử có thể tái sử dụng trong GraphQL Query. Trong GraphQL sẽ có những lúc bạn gặp phải những tình huống mà bạn cần phải query các field giống nhau trong các câu query khác nhau. Khi mà bạn nhận thấy các câu query của bạn có nhiều các field bị lặp lại tại nhiều vị trí khác nhau. Bạn có thể tóm chúng lại thành một đơn vị có thể tái sử dụng gọi là Fragment. Một GraphQL Fragment cho phép bạn khai báo một bộ các field và sử dụng chúng trong nhiều câu query. Bạn có thể liên tưởng Fragment trong GraphQL có nét tương đồng như là function trong nhiều ngôn ngữ lập trình. Bạn khai báo function ở một chỗ và bạn gọi đến function ở nhiều chỗ dùng đến nó. Chúng đều là các phần tử tái sử dụng được. 2. Các thành phần của một Fragment Chúng ta hãy đi vào tìm hiểu các thành phần của một Fragment với cấu trúc mẫu bên dưới12345fragment Name on TypeName &#123; field1 field2 field3&#125; Một Fragment sẽ bao gồm 3 thành phần sau Name: Tên riêng biệt cho 1 Fragment (mỗi một Fragment có 1 tên riêng) TypeName: Kiểu của object trong GraphQL Schema mà Fragment được tạo ra từ đó, hay được lồng trong đó Body: Body của Fragment định nghĩa các trường nào sẽ được query (field1, field2, field3) 3. Lợi ích của việc sử dụng GraphQL FragmentTại sao Fragment lại là một khái niệm rất “cool” trong GraphQL Thứ nhất, bởi tính tái sử dụng của Fragment: Với Fragment, bạn có thể cấu trúc các câu query của bạn thành các phần tử có thể sử dụng được ở nhiều chỗ mà không cần phải viết lặp đi lặp lại. Caching: GraphQL Client tận dụng các Fragment để cung cấp các option caching. Xem thêm apollographql.com/docs/react/caching/cache-interaction/ 4. Tạo GraphQL Fragment Chúng ta hãy cùng học cách tạo một GraphQL Fragment qua một vài ví dụ nhé. Trong những ví dụ trong bài viết này, mình sử dụng Github’s public API và viết query dựa trên nó. Bạn cũng có thể chạy các câu query trên Github GraphQL Explorer1234567891011121314151617181920&#123; googleRepo: repository(owner: &quot;google&quot;, name: &quot;WebFundamentals&quot;) &#123; name owner &#123; id avatarUrl resourcePath url &#125; &#125; facebookRepo: repository(owner: &quot;facebook&quot;, name: &quot;react&quot;) &#123; name owner &#123; id avatarUrl resourcePath url &#125; &#125;&#125; Chúng ta nhận thấy ở đây là chúng ta đang query cùng các field bên trong field owner nhiều lần. Đây là lúc thích hợp để chúng ta sử dụng Fragment Chúng ta sẽ tạo một fragment gọi là ownerInfo với từ khoá fragment. Để tạo một Fragment chúng ta phải nói cho GraphQL biết rằng Fragment này được tạo ra trên field nào. Trong trường hợp này, chúng ta sẽ tạo 1 Fragment trên fieldRepositoryOwner Trong Body của Fragment, chúng ta có thể bao gồm tất cả các field của đối tượng RepositoryOwner. Ở đây chúng ta định nghĩa các field là id, avatarUrl, resourcePath, url là các field của fragment ownerInfo1234567// fragment ownerInfo for RepositoryOwner fieldsfragment ownerInfo on RepositoryOwner &#123; id avatarUrl resourcePath url&#125; 5. Sử dụng một GraphQL Fragment Chúng ta có thể sử dụng Fragment mà chúng ta sử dụng ở ví dụ trước trong phạm vi một query bằng việc sử dụng toán tử ... và theo sau là tên của Fragment 12345678910111213141516// GraphQL Query with fragments&#123; googleRepo: repository(owner: &quot;google&quot;, name: &quot;WebFundamentals&quot;) &#123; name owner &#123; ...ownerInfo //fragment &#125; &#125; facebookRepo: repository(owner: &quot;facebook&quot;, name: &quot;react&quot;) &#123; name owner &#123; ...ownerInfo //fragment &#125; &#125;&#125; Response của query khi chúng ta sử dụng Fragment sẽ không thay đổi so với khi chúng ta không sử dụng Fragment. Fragment chỉ đơn giản là làm cho câu query được clean hơn, dễ đọc, và tái sử dụng 123456789101112131415161718192021222324// GraphQL JSON Response&#123; &quot;data&quot;: &#123; &quot;googleRepo&quot;: &#123; &quot;name&quot;: &quot;WebFundamentals&quot;, &quot;owner&quot;: &#123; &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ=&quot;, &quot;avatarUrl&quot;: &quot;https://avatars1.githubusercontent.com/u/1342004?v=4&quot;, &quot;resourcePath&quot;: &quot;/google&quot;, &quot;url&quot;: &quot;https://github.com/google&quot; &#125; &#125;, &quot;facebookRepo&quot;: &#123; &quot;name&quot;: &quot;react&quot;, &quot;owner&quot;: &#123; &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;, &quot;avatarUrl&quot;: &quot;https://avatars3.githubusercontent.com/u/69631?v=4&quot;, &quot;resourcePath&quot;: &quot;/facebook&quot;, &quot;url&quot;: &quot;https://github.com/facebook&quot; &#125; &#125; &#125;&#125; 6. Kết luận Fragment là một khái niệm rất thú vị trong GraphQL, nó cho phép tái sử dụng trong khi viết các câu query, loại bỏ các đoạn mã phải viết đi viết lại, giúp các câu query dễ đọc dễ hiểu hơn. Mong qua bài viết này, các bạn sẽ hiểu hơn về khái niệm Fragment và có thể sử dụng Fragment khi viết GraphQL Schema cũng như không bỡ ngỡ mỗi khi đọc Schema có sử dụng Fragment Nguồn tham khảo https://blog.logrocket.com/graphql-fragments-explained/ https://graphql.org/learn/queries/#fragments","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"fragment","slug":"fragment","permalink":"https://huongvnq.github.io/tags/fragment/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"}]},{"title":"GraphQL SDL - Schema Definition Language Phần 2","slug":"graphql-sdl-2","date":"2021-02-21T04:33:14.000Z","updated":"2021-07-23T04:39:43.912Z","comments":true,"path":"2021/02/21/graphql-sdl-2/","link":"","permalink":"https://huongvnq.github.io/2021/02/21/graphql-sdl-2/","excerpt":"","text":"Nối tiếp Phần một về Schema Difinition Language của GraphQL, bài viết này trình bày tiếp các khái niệm được sử dụng để định nghĩa GraphQL Schema 1. Interfaces Cũng giống như khái niệm Interface ở các language khác, trong GraphQL, một Interface là một asbstract type có thể bao gồm một tập nhất định các field mà các type khi implement nó cũng phải bao gồm các field đó. Ví dụ, bạn có một interface Character đại diện cho bất kì nhân vật nào trong Star Wars 123456interface Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]!&#125; Bất kì type nào mà Implements Characters cần phải có đầy đủ các trường trên với cùng tham số hay cùng type. Ví dụ, các type sau đây có thể implement Character 12345678910111213141516type Human implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int&#125;type Droid implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String&#125; Cả 3 type này đều có tất cả các trường từ Character interface, đồng thời cũng có các trường bổ sung như totalCredits, starships, primaryFunction giúp xác định các loại Character cụ thể. Interface hữu ích khi mà bạn muốn trả về một object hay là một bộ các object, nhưng chúng lại có các trường khác nhau. Ví dụ, câu query sau sẽ sinh ra lỗi QUERY DEFINITION 123type Query &#123; hero(episode: Episode): Character&#125; CLIENT CALL QUERY 123456query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name primaryFunction &#125;&#125; VARIABLES 123&#123; &quot;ep&quot;: &quot;JEDI&quot;&#125; RESULT 12345678910111213&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;Cannot query field \\&quot;primaryFunction\\&quot; on type \\&quot;Character\\&quot;. Did you mean to use an inline fragment on \\&quot;Droid\\&quot;?&quot;, &quot;locations&quot;: [ &#123; &quot;line&quot;: 4, &quot;column&quot;: 5 &#125; ] &#125; ]&#125; Trường hero trả về một kiểu Character, nó có thể là Human hay Droid tùy thuộc vào biến episode. Trong câu query trên bạn chỉ có thể chỉ định trả về những field mà tồn tại trong Character interface, như vậy sẽ không có primaryFunction Để yêu cầu trả về các trường trong một object type cụ thể, sử dụng inline fragments 2. Union types Ví dụ 1union SearchResult = Human | Droid | Starship Bất cứ khi nào chúng ta trả về một loại Search Result trong schema, SearchResult này có thể là một Human, Droid, hoặc một Starship. Các thành phần của một union type cần phải là một loại đối tượng cụ thể, không được là một interface hay là một union khác Khi phía client query một field mà trả về một union type là SearchResult, chúng ta cần phải sử dụng inline fragment để có thể query bất kì trường nào. CLIENT QERRY 1234567891011121314151617&#123; search(text: &quot;an&quot;) &#123; __typename ... on Human &#123; name height &#125; ... on Droid &#123; name primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125; RESULT 123456789101112131415161718192021 &quot;data&quot;: &#123; &quot;search&quot;: [ &#123; &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Han Solo&quot;, &quot;height&quot;: 1.8 &#125;, &#123; &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Leia Organa&quot;, &quot;height&quot;: 1.5 &#125;, &#123; &quot;__typename&quot;: &quot;Starship&quot;, &quot;name&quot;: &quot;TIE Advanced x1&quot;, &quot;length&quot;: 9.2 &#125; ] &#125;&#125; Trường __typename là một String giúp bạn phân biệt sự khác nhau giữa các object type ở Client Ở ví dụ này, vì Human và Droid cùng implement một interface chung là Character nên bạn có thể query những trường chung của 2 object type này ở chỉ một chỗ mà không cần lặp lại các trường giống nhau ở mỗi type, ví dụ sau đây cho kết quả như bên trên:123456789101112131415161718&#123; search(text: &quot;an&quot;) &#123; __typename ... on Character &#123; name &#125; ... on Human &#123; height &#125; ... on Droid &#123; primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125; Lưu ý: Trường name vẫn phải được chỉ định đối với Starship bởi Starship không phải là một Character 3.Input types Từ đầu đến giờ, chúng ta chỉ nói về truyền vào một field các argument thuộc về kiểu scalar như enums hay strings. Tuy nhiên bạn có thể truyền argument là một object phức tạp. Điều này cực kì hữu ích khi bạn muốn truyền vào toàn bộ object để tạo cái gì đó. Trong GraphQL SDL, input types nhìn sẽ giống một object types thông tường nhưng với keyword input thay vì type 1234input ReviewInput &#123; stars: Int! commentary: String&#125; Ví dụ sử dụng input type trong một mutation MUTATION DEFINITION 123456mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125; VARIABLES 1234567&#123; &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125;&#125; RESULT 12345678&#123; &quot;data&quot;: &#123; &quot;createReview&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125; &#125;&#125; 4. Kết luận Quan hai phần của chủ đề này, mình đã trình bày các khái niệm được sử dụng trong Schema Difinition Language. Mình tin là những khái niệm này đủ để bạn có thể tự định nghĩa một schema cơ bản của mình. Mong bài viết có ích đối với các bạn Nguồn tham khảo https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51 https://graphql.org/learn/schema","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"}]},{"title":"GraphQL SDL - Schema Definition Language Phần 1","slug":"graphql-sdl-1","date":"2021-02-21T04:29:05.000Z","updated":"2021-07-23T04:32:00.536Z","comments":true,"path":"2021/02/21/graphql-sdl-1/","link":"","permalink":"https://huongvnq.github.io/2021/02/21/graphql-sdl-1/","excerpt":"","text":"1. GraphQL Schema Difinition Language là gì? Qua các bài viết trước trong series về GraphQL, chúng ta đã hiểu được các khái niệm GraphQL, Schema. GraphQL có một ngôn ngữ riêng để định nghĩa Schema đó là GraphQL Schema Definition Language (SDL) SDL là một ngôn ngữ có cú pháp rất đơn giản, dễ hiểu đồng thời cũng rất mạnh mẽ và trực quan giúp định nghĩa schema một các cô đọng nhất. Ví dụ sử dụng SDL để định nghĩa Schema cho một ứng dụng blogging đơn giản12345678910111213type Post &#123; id: String! title: String! publishedAt: DateTime! likes: Int! @default(value: 0) blog: Blog @relation(name: &quot;Posts&quot;)&#125;type Blog &#123; id: String! name: String! description: String posts: [Post!]! @relation(name: &quot;Posts&quot;)&#125; Các thành phần chính của bản định nghĩa schema gồm có types và fields. Ngoài ra các thông tin bổ sung khác có thể được cung cấp là các custom directives như @default value được chỉ định cho trường likes hay @relation chỉ định mối quan hệ … Có rất nhiều thứ để nói ở đây, chúng ta hãy đi vào tìm hiểu chi tiết nhé. 2. Object types và fields Phần tử cơ bản nhất của GrapQL Schema là object types, đại diện cho một loại đối tượng mà bạn có thể lấy được từ server. Ví dụ1234type Character &#123; name: String! appearsIn: [Episode!]!&#125; Character là một GraphQL Object Type, là một kiểu đối tượng với các trường (field). Hầu hết các type trong schema của bạn đều là các object types name và appearsIn là các field của Character. Điều này có nghĩa là name và appearsIn là các trường duy nhất được chỉ định khi truy vấn Character Một field thì gồm có name và type. String ở đây là type của field name, là một scalar type được xây dựng sẵn. Chúng ta sẽ đi vào tìm hiểu về scalar type ở bên dưới nhé. Một field ngoài có kiểu scalar type thì có thể thuộc về bất kì kiểu nào tự định nghĩa trong schema. Một field không thể null được biểu thị bằng dấu ! , server bắt buộc phải trả về dữ liệu cho trường này khi bạn query. Một field có kiểu là mảng được chỉ định bằng [], ở đây appearsIn là một mảng các Episode. 3. Arguments Mỗi một trường của một object type có thể không có hoặc có nhiều các đối số. VÍ dụ như trường lenght bên dưới:12345type Starship &#123; id: ID! name: String! length(unit: LengthUnit = METER): Float&#125; Không giống các ngôn ngữ lập trình khác như JavaScript hay Python, các function sẽ nhận các tham số theo thứ tự khi định nghĩa functon, trong GraphQL, các field sẽ nhận các tham số theo tên được truyền vào, thứ tự các tham số không ảnh hưởng. Trong ví dụ trên trường length có một tham số được định nghĩa là unit Một argument có thể required hoặc không. Khi một tham số là không required, chúng ta có thể định nghĩa default value cho nó, nếu tham số unit không được truyền vào, nó sẽ có giá trị default là METER 4. Scalar types Scalar type là kiểu cho một đối tượng vô hướng, có nghĩa là đối tượng này không có sub-selections (các trường con), chúng được coi là các lá của query. Có 5 loại Scalar type được định nghĩa trong SDL Int: Một số nguyên 32-bit không dấu Float: Một số thực dấu phẩy động String: Một chỗi UTF-8 Boolean: true hoặc false ID: là một chuỗi định danh duy nhất, thường được sử dụng để lấy một object từ server Ngoài các kiểu scalar type được định sẵn, chúng ta có thể tự định nghĩa các custom scalar type. Ví dụ ta có thể định nghĩa một kiểu Date1scalar Date Đối với type Date chúng ta có thể validate hay format theo dạng Y/mm/dd, như vậy bất kì trường Date nào mà server trả về đều sẽ có dạng Y/mm/dd 5. Enumeration types Enums cũng là một kiểu đặc biệt của scalar type, được giới hạn trong một giá trị cho phép cụ thể, chúng ta có thể validate bất kì argument nào thuộc loại này chỉ có gía trị trong những giá trị cho phép. Ví dụ12345enum Episode &#123; NEWHOPE EMPIRE JEDI&#125; Với bất kì field nào có kiểu Episode thì chỉ có thể là NEWHOPE, EMPIRE, hay JEDI 6. Kết phần 1 Trong bài viết này mình đã trình bày một số khái niệmcơ bản và hay sử dụng nhất khi định nghĩa một GraphQL Schema. Sang phần 2 mình sẽ trình bày các khái niệm phức tạp hơn nhưng cũng rất quan trọng và hữu ích Nguồn tham khảo https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51 https://graphql.org/learn/schema/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"}]},{"title":"Cấu trúc cú pháp cơ bản của GraphQL","slug":"graphql-core-concepts","date":"2020-10-18T04:23:59.000Z","updated":"2021-07-23T04:50:13.033Z","comments":true,"path":"2020/10/18/graphql-core-concepts/","link":"","permalink":"https://huongvnq.github.io/2020/10/18/graphql-core-concepts/","excerpt":"","text":"1. Ngôn ngữ định nghĩa Schema - The Schema Definition Language (SDL) Như đã nói ở những bài viết trước về GraphQL, GraphQL sử dụng Schema như là một bản hợp đồng giữa Client và Server, một bản “quy chuẩn ngôn ngữ” giữa Client và Server, Client có thể dùng những cái định nghĩa trong Schema để gửi lên server lấy dữ liệu từ server và server cũng dựa vào đó để có thể biết mình làm gì và trả về kết quả gì cho Client. GraphQL có một ngôn ngữ riêng để định nghĩa Schema. Đó là Schema Definition Language (SDL) Ví dụ chúng ta có thể sử dụng SDL để định nghĩa một simple type Person:php type Person &#123; name: String! age: Int! &#125;type này có 2 trường, name và age tương ứng thuộc loại String và Int. Dấu ! theo sau kiểu dữ liệu có nghĩa là trường này là required Chúng ta cũng có thể mô tả mối quan hệ (relationship) giữa 2 trường. Ví dụ về một ứng dụng blog, một Person có thể có nhiều bài Post1234type Post &#123; title: String! author: Person!&#125; Ngược lại, ta khai báo type Person và đặt vào một chiều của mối quan hệ:php type Person &#123; name: String! age: Int! posts: [Post!]! &#125;Như bên trên, ta đã tạo một mối quan hệ one-to-many giữa Person và Post bởi trường posts trong type Person là một mảng các Post. Khai báo mối quan hệ như này giúp cho Client có thể chỉ định các cấu trúc query lồng nhau, như vậy có thể lấy được toàn bộ dữ liệu mình cần chỉ trong một endpoint và không phải dùng nhiều endpoint như REST. Để biết thêm về các cú pháp khác của SDL, tham khảo: https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51 2. Fetching Data với Queries. Khi làm việc với REST APIs, dữ liệu được load từ những endpoint được chỉ định. Mỗi endpoint có một cấu trúc được định nghĩa rõ ràng về những thông tin mà nó trả về. Đối với cách tiếp cận của GraphQL, thay vì có nhiều endpoints trả về dữ liệu cố định, GraphQL APIs chỉ dùng 1 endpoint và để cho người dùng có thể quyết định data thực sự cần để trả về. Do đó Client cần phải gửi nhiều thông tin hơn tới server để diễn tả yêu cầu về data, thông tin đó được gọi là query Ví dụ về một query mà client có thể gửi tới server 12345&#123; allPersons &#123; name &#125;&#125; allPersons được gọi là root field của query. Mọi thứ theo sau root field được gọi là payload của query. Ở đây chỉ có 1 field được chỉ định trong query payload là field name Câu query trên sẽ trả về danh sách tất cả các Person với tên của nó: 1234567&#123; &quot;allPersons&quot;: [ &#123; &quot;name&quot;: &quot;Johnny&quot; &#125;, &#123; &quot;name&quot;: &quot;Sarah&quot; &#125;, &#123; &quot;name&quot;: &quot;Alice&quot; &#125; ]&#125; Mỗi một person chỉ có trường name trong response trả về, trường age không trả về vì nó không cần thiết đối với Client. Nếu Client cũng cần trường age, tất cả những gì Client phải làm là điều chỉnh câu query và thêm trường vào payload. 123456&#123; allPersons &#123; name age &#125;&#125; Một trong những lợi thế lớn của GraphQL là nó cho phép truy vấn lồng nhau một cách tự nhiên. Ví dụ, bạn muốn load tất cả các bài posts của một Person, bạn có thể viết query như sau: 123456789&#123; allPersons &#123; name age posts &#123; title &#125; &#125;&#125; Server sẽ trả về response như sau: 123456789101112131415161718192021 &#123; &quot;allPersons&quot;: [ &#123; &quot;name&quot;: &quot;Binz&quot;, &quot;posts&quot;: [ &#123; &quot;title&quot;: &quot;GraphQL is awesome&quot; &#125;, &#123; &quot;title&quot;: &quot;Relay is a powerful GraphQL Client&quot;&#125; ] &#125;, &#123; &quot;name&quot;: &quot;Karik&quot;, &quot;posts&quot;: [ &#123; &quot;title&quot;: &quot;Let&#x27;s get started with React &amp; GraphQL&quot; &#125;, ] &#125;, &#123; &quot;name&quot;: &quot;Suboy&quot;, &quot;posts&quot;: [] &#125; ]&#125; Queries với Arguments:Trong GraphQL, mỗi field có thể có không hoặc nhiều tham số. Ví dụ, field allPersonscó thể có tham số last để chỉ trả về một số lượng nhất định person.&#123; allPersons(last: 2) &#123; name &#125; &#125; 3. Writing Data with Mutations. Bên cạnh việc request data từ server, phía Client cũng cần phải making some changes tới data được lưu ở phía backend. Với GraphQL, ta có thể sử dụng mutations để làm điều đó. Nói chung, có 3 loại mutations: tạo mới data cập nhật data đã tồn tại Xóa data đã tồn tại. Mutations tuân theo cấu trúc cú pháp giống như queries, tuy nhiên nó luôn luôn phải bắt đầu với keyword mutation. Ví dụ chúng ta tạo mới một Person:123456mutation &#123; createPerson(name: &quot;Sam&quot;, age: 23) &#123; name age &#125;&#125; Tương tự với query, mutation cũng có một root field, ở đây là createPerson. Ở đây field createPerson nhận vào 2 tham số là name và age. Theo sau root field createPerson là payload cho mutation, ở đây là 2 trương name và age, là chỉ định dữ liệu trả về phía server. Với mutation trên, Server sẽ trả về response như sau:1234&quot;createPerson&quot;: &#123; &quot;name&quot;: &quot;Sam&quot;, &quot;age&quot;: 23,&#125; 4. Realtime Với Subscriptions Một yêu cầu đối với nhiều ứng dụng hiện nay là tính realtime với server, cho phép nhận được thông báo ngay lập tức về các sự kiện quan trọng. Đối với trường hợp này GraphQL cung cấp khái niệm subscriptions. Khi một Client subscribes một event, một kết nối tới máy chủ sẽ được khởi tạo và giữ ổn định. Khi có một event cụ thể nào diễn ra, server sẽ đẩy dữ liệu tương ứng về cho client. Nếu Queries và Mutations tuân theo “request-response-cycle“, subscriptions sẽ đại điện cho stream of data (dòng chảy dữ liệu) gửi tới client. Ví dụ chúng ta subcribe một event:123456subscription &#123; newPerson &#123; name age &#125;&#125; Sau khi client gửi subscription tới server, một kết nối đã được mở giữa client và server. Sau đó bất cứ khi nào mutation tạo mới Person được thực thi, server sẽ gửi thông tin về person này tới client:123456&#123; &quot;newPerson&quot;: &#123; &quot;name&quot;: &quot;Sam&quot;, &quot;age&quot;: 23 &#125;&#125; 5. Định nghĩa Schema cho Queries, Mutations và Subscriptions. Để Client có thể sử dụng Queries, Mutations và Subscriptions như trên, chúng ta phải định nghĩa chúng ở Schema. Nói tóm lại, một schema đơn giản là một tập hợp của các GraphQL type. Ngoài các type như Post, Person mà chúng ta ví dụ ở phần 1, chúng ta còn có các type đặc biệt như: 123type Query &#123; ... &#125;type Mutation &#123; ... &#125;type Subscription &#123; ... &#125; Để Client có thể gọi được query allPersons như ở ví dụ bên trên, chúng ta phải định nghĩa chúng trong type Query: 123type Query &#123; allPersons: [Person!]!&#125; Tương tự với mutation createPerson và subscription newPerson, chúng ta sẽ có một tổng thể schema như sau: 12345678910111213141516171819202122232425type Query &#123; allPersons(last: Int): [Person!]!&#125;type Mutation &#123; createPerson(name: String!, age: Int!): Person! updatePerson(id: ID!, name: String!, age: Int): Person!&#125;type Subscription &#123; newPerson: Person!&#125;type Person &#123; id: ID! name: String! age: Int! posts: [Post!]!&#125;type Post &#123; id: ID! title: String! author: Person!&#125; 6. Một chút về Resolver. Chúng ta đã có schema (như chúng ta đã biết, schema như một hợp đồng làm việc giữa client và server), chúng ta biết cách gọi các truy vấn (được định nghĩa ở schema) từ phía client. Vậy còn phía server, làm sao để từ file schema, server biết được mình sẽ xử lý như thế nào để trả về cho client. Chúng ta sẽ có các hàm resolver. Ứng với mỗi field trong các type, sẽ có một resolver được định nghĩa để giải quyết yêu cầu phía client và trả về dữ liệu cho client. Các argument truyền vào các field cũng chính là những tham số được truyền vào resolvers. Trên đây là khái quát về resolver, mình trình bày chi tiết về resolver trong bài viết lần sau. Nguồn tham khảo: https://www.howtographql.com/basics/2-core-concepts/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"}]},{"title":"So sánh GrapQL với REST","slug":"graphql-vs-rest","date":"2020-10-18T03:57:28.000Z","updated":"2021-07-25T03:22:04.134Z","comments":true,"path":"2020/10/18/graphql-vs-rest/","link":"","permalink":"https://huongvnq.github.io/2020/10/18/graphql-vs-rest/","excerpt":"","text":"1. Giới thiệu chung Trải qua nhiều thập kỉ, REST đã trở thành một tiêu chuẩn cho thiết kế Web API. REST có những ý tưởng rất tuyệt vời như là stateless servers hay là structured access to resources. Tuy nhiên REST APIs vẫn còn chưa linh hoạt để bắt kịp với những yêu cầu thay đổi nhanh chóng phía client. GraphQL được phát triển để đáp ứng nhu cầu linh hoạt hơn và hiệu quả hơn. Nó giải quyết nhiều những thiếu sót và kém hiệu quả mà developer đã trải nghiệm được sau một thời gian làm việc với REST API. Ở bài viết lần trước mình cũng đã chia sẻ qua về GraphQL là gì, bài viết này mình sẽ đặt nó bên cạnh REST để làm nổi bật lên những ưu điểm vượt trội hơn so với REST. 2. Ưu điểm của GraphQL so với REST REST GraphQL Data Fetching Nhiều Endpoint 1 Endpoint Imperative data fetching Declarative Data Fetching Tồn tại Over Fetching và UnderFetching Giải quyết OverFetching và UnderFetching Khi yêu cầu Client thay đổi Phải Thay đổi phía server Có thể chỉ Phải Thay đổi phía Client Độ phụ thuộc giữa Backend và Frontend Không thể làm việc độc lập Có thể làm việc độc lập Phân tích sự dư thừa dữ liệu Không thể phân tích được sự dư thừa dữ liệu Có thể phân tích được sự dư thừa dữ liệu và hiệu suất của ứng dụng. 2.1 Data Fetching với GraphQL và RESTĐể làm rõ sự khác nhau giữa REST và GraphQL khi fetching data từ API, chúng ta hãy xem xét một kịch bản đơn giản sau: Với một ứng dụng blog, ứng dụng sẽ cần hiển thị list tiêu đề các bài post của một user cụ thể. Cùng màn hình đó, bạn cũng cần phải hiển thị tên của 3 followers của user đó. Hãy cùng xem cách mà REST và GraphQL xử lý. 2.1.1 Multiple Endpoint và Single Endpoint Với REST API, bạn sẽ lấy data bằng việc sử dụng nhiều endpoint. Với kịch bản trên, Bạn sẽ sử dụng 1 endpoint /users/{id} để lấy dữ liệu của user. Sau đó bạn sẽ sử dụng 1 endpoint nữa là /user/{id}/posts để lấy tất cả các bài post của user. Endpoint thứ ba sẽ là /user/{id}/followers trả về danh sách các follower của user. Với GraphQL, bạn chỉ cần đơn giản gửi một câu query tới GraphQL Server bao gồm các yêu cầu dữ liệu cụ thể. Server sẽ trả về một JSON object đáp ứng các yêu cầu client gửi lên. Chú ý rằng Cấu trúc response mà Server trả về sẽ tuân theo chính xác cấu trúc lồng nhau mà được chỉ định trong query gửi lên từ Client. 2.1.2 GraphQL giải quyết Overfetching và UnderfetchingMột vấn đề thông thường nhất gặp phải với REST là Overfetching và Underfetching. Điều này xảy ra do Client sử dụng endpoint để lấy dữ liệu về, và các endpoint thì trả về cấu trúc dữ liệu cố định. Điều này dẫn đến những khó khăn cho việc thiết kế API làm thế nào để có thể cung cấp cho client chính xác những gì mà client cần. Overfetching: Trả về dư thừa dữ liệu cho Client Overfetching có nghĩa là một Client lấy được nhiều thông tin hơn so với những gì nó cần. Ví dụ dễ hiểu một màn hình cần hiển thị danh sách các user chỉ với tên của các user đó. Nhưng với REST API, bạn gọi endpoint /users và nhận về mảng JSON các dữ liệu của user. Response có thể chứa nhiều thông tin của user như ngày sinh, địa chỉ của user…, những thông này vô dụng với client vì client chỉ cần hiển thị tên của các user. Underfetching và vấn đề n+1 Underfetching có nghĩa là một endpoint cụ thể không cung cấp đủ thông tin yêu cầu cho client. Client phải thực hiện thêm những request khác để lấy thêm dữ liệu mà nó cần. Khi đó vấn đề n+1 xảy ra khi mà đầu tiên Client cần lấy về một list các phần tử, nhưng sau đó đối với mỗi phần tử lại phải tạo một request để lấy dữ liệu yêu cầu của mỗi phần tử! Ví dụ với kịch bản ứng dụng cần hiển thị list user, và mỗi user cần hiển thị 3 followers gần nhất. Đầu tiên ứng dụng cần phải gọi 1 endpoint /users và sau đó ứng với mỗi user, chúng ta phải thực hiện một endpoint bổ sung là /users//followers Với việc sử dụng 1 endpoint, cho phép client chỉ định những dữ liệu nào mà client cần, server trả về đúng dữ liệu theo cấu trúc lồng nhau được chỉ định trong query của client thì GraphQL đã giải quyết được vấn đề Overfetching và Underfetching. 2.1.3 Imperative data fetching và Declarative Data Fetching REST theo phương pháp Imperative data fetching (Tìm nạp dữ liệu mệnh lệnh). Khi fetching data từ REST API, một ứng dụng cần phải thực hiện các bước sau: Gửi dữ liệu HTTP request (vd fetch trong javascript) Nhận và parse dữ liệu nhận được từ server. Store dữ liệu dưới local. Hiển thị dữ liệu trên UI GraphQL tiếp cận theo ý tưởng declarative data fetching (Tìm nạp dữ liệu khai báo), Client chỉ việc thực hiện 2 bước sau: Mô tả yêu cầu dữ liệu. Hiển thị dữ liệu trên UI. Cách tiếp cận này tập trung vào việc Client sẽ khai báo dữ liệu (declarative data), còn trừu tượng hóa các tác vụ khác cũng như việc lưu trữ dữ liệu. 2.2 Vấn đề đáp ứng sự thay đổi nhanh chóng phía Client. Với REST API, Client sẽ gọi các endpoint tương ứng cho các view, server sẽ trả về tất cả các thông tin được yêu cầu cho một view cụ thể. Tuy nhiên điểm yếu của REST API ở chỗ này là nó sẽ không đáp ứng nhanh chóng sự thay đổi phía Client. Với mỗi sự thay đổi phía UI (chẳng hạn như yêu cầu nhiều dữ liệu hơn), thì phía backend (server) cũng phải thay đổi để đáp ứng yêu cầu dữ liệu mới. Nó sẽ làm giảm hiệu suất, và chậm việc update product liên tục. Với GraphQL, vấn đề này đã được giải quyết. Nhờ có sự linh hoạt phía GraphQL, sự thay đổi phía Client sẽ không dẫn đến phải thay đổi phía server, bởi client có thể chỉ định chính xác yêu cầu dữ liệu mà client cần, do đó chỉ việc thay đổi phía Client. 2.3 Độ phụ thuộc giữa Backend và Frontend - Lợi thế của Schema và Type của GraphQL GraphQL sử dụng hệ thống Type và sử dụng Schema Definition Language (SDL) để định nghĩa Schema. Hãy hiểu Schema như là một hợp đồng giữa Client và Server, một bản mô tả cách mà client có thể lấy dữ liệu trên Server. Một khi Schema đã được định nghĩa, team frontend và team backend có thể làm việc độc lập và không cần trao đổi với nhau nhiều vì cả 2 bên đã biết được cấu trúc dữ liệu sẽ được transfer như nào. Team Frontend có thể tạo dummy test data để test ứng dụng và khi server đã sẵn sàng, team frontend sẽ chuyển sang lấy dữ liệu từ API thực tế. Điều này giúp tăng hiệu suất làm việc rất nhiều. 2.4 Phân tích sự dư thừa dữ liệu Với REST API, chúng ta có toàn bộ dữ liệu được trả về trong một API endpoint, như vậy chúng ta sẽ không biết được thông tin về việc sử dụng các trường dữ liệu cụ thể. Đối với GraphQL, chúng ta sẽ chỉ định chính xác những gì chúng ta cần, như vậy chúng ta sẽ biết được trường dữ liệu nào đang được sử dụng và trường dữ liệu nào không được request từ Client nữa. Hơn nữa, GraphQL sử dụng resolver function để xử lý dữ liệu mà client yêu cầu. Các phương pháp đo lường hiệu suất cho các resolvers sẽ giúp bạn nhìn thấy được những chỗ “cổ chai” trong ứng dụng của bạn, giúp bạn có thể theo dõi được performance của hệ thống. 3. Nhược điểm của GraphQL GraphQL luôn trả về HTTP status code là 200, bất kể query có success hay không. Nếu query fail, JSON response trả về sẽ có key errors, với các error message và stacktrace. Điều này gây khó khăn hơn trong việc error handling. Phải thiết kế Schema trước, sẽ vất vả hơn vì thêm việc mặc dù sau này schema sẽ giúp bạn ngăn chặn nhiều lỗi và đỡ tốn sức hơn khi nâng cấp. Khi Client không cần quan tâm đến data lấy từ đâu thì Sự phức tạp được đẩy về phía server, GraphQL không phải là giải pháp tốt cho các ứng dụng đơn giản. Vấn đề caching. REST API sử dụng nhiều endpoint nên nó tận dùng HTTP caching để tránh việc phải tìm nạp lại tài nguyên. Với GraphQL, nó sử dụng 1endpoint thay vì theo cơ chế caching của HTTP. Lưu vào bộ nhớ đệm là rất quan trọng vì nó làm giảm sự truy cập vào máy chủ. Với GraphQL, bạn phải sử dụng thư viện khác phía Client để đáp ứng việc caching. 4. Kết luận Bài viết trên mình đã trình bày sự khác nhau giữa REST và GraphQL qua những ưu nhược điểm của GraphQL so với REST. Cả REST và GraphQL đều là những cách nổi bật để thiết kế API. REST đơn giản hóa đáng kể công việc của dev với cách tiếp cận tiêu chuẩn, tuy nhiên nó cũng có vài nhược điểm. GraphQL giải quyết những nhược điểm của REST và có nhiều ưu điểm vượt trội hơn so với REST, tuy nhiên không phải lúc nào nó cũng là giải pháp tốt nhất. Đối với những ứng dụng xử lý dữ liệu tương đối nhất quán, mình nghĩ nên sử dụng REST API. Còn đối với những ứng dụng mà cần xử lý với dữ liệu thay đổi nhanh chóng, yêu cầu update product liên tục thì hãy trải nghiệm với GraphQL. Anyway, bạn có thể sử dụng cả REST và GraphQL trong 1 project. Hãy phân tích ứng dụng của bạn và yêu cầu hiệu suất để có lựa chọn thích hợp nhé. Hẹn gặp lại các bạn trong các bài viết tiếp theo của Series GraphQL. Nguồn tham khảo: https://www.howtographql.com/basics/1-graphql-is-the-better-rest/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"REST API","slug":"REST-API","permalink":"https://huongvnq.github.io/tags/REST-API/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"}]},{"title":"Giới thiệu chung về GraphQL","slug":"introduction-graphql","date":"2020-10-18T03:00:58.000Z","updated":"2021-08-21T02:20:22.184Z","comments":true,"path":"2020/10/18/introduction-graphql/","link":"","permalink":"https://huongvnq.github.io/2020/10/18/introduction-graphql/","excerpt":"","text":"1. Nhắc lại về REST REST (Representational State Transfer): được sáng lập bởi người sáng lập ra phương thức HTTP. Là một tiêu chuẩn để viết API, sử dụng phương thức HTTP đơn giản để giao tiếp giữa các máy. REST gửi một yêu cầu HTTP như GET, POST, UPDATE, DELETE đến một URL để xử lý dữ liệu REST mang lại rất nhiều ưu điểm (ứng dụng rõ ràng, code dễ dàng đơn giản hơn, dữ liêu trả về dưới nhiều định dạng…). Ttrải qua rất nhiều năm, REST là cách phổ biến nhất để client giao tiếp server. REST cũng là giải pháp phù hợp với rất nhiều ứng dụng đặc biệt là các ứng dụng đơn giản, tốc độ phát triển chậm. Tuy nhiên ngày nay, nhiều ứng dụng lại có tốc độ phát triển nhanh, thay đổi cập nhật liên tục, dẫn đến các API cũng phải thay đổi dữ liêu trả về tương ứng… Điều này dẫn đến ra đời GraphQL 2. GraphQL là gì? Là một tiêu chuẩn API mới cung cấp một giải pháp thay thế hiệu quả, mạnh mẽ, linh hoạt hơn so với REST. Cho phép Client có thể chỉ định chính xác những data nào mà Client thật sự cần từ một API. Thay vì multiple endpoints trả về cấu trúc data cố định, GraphQL chỉ sử dụng Một endpoint, và trả về chính xác dữ liệu mà client yêu cầu. GraphQL thường bị nhầm tưởng là một công nghệ Database. Điều đó là quan niệm sai lầm. GraphQL là một query language cho API, không phải cho database. Điều đó có nghĩa là chúng ta có thể sử dụng GraphQL mà không cần quan tâm database là gì. 3. Tại sao lại phát triển GraphQL Sự ra tăng của các việc sử dụng các thiết bị mobile, nhiều thiết bị mobile công suất thấp, mạng yếu, đòi hỏi cần phải load dữ liệu một cách hiệu quả.Đây là lý do Facebook sáng chế ra GraphQL. GraphQL giảm thiểu số lượng data transfer qua mạng. Có nhiều các framework và platform frontend khác nhau.Gây khó khăn cho việc xây dựng và bảo trì một API mà đáp ứng yêu cầu của các framework và platform. Với GraphQL, mỗi client có thể truy cập chính xác đc dữ liệu nó cần. Đáp ứng sự triển khai nhanh chóng liên tục và cập nhật product thường xuyên.Với Rest API, phía máy chủ cần được sửa đổi để giải quyết các yêu cầu cụ thể và thay đổi design phía clients. Điều này cản trở yêu cầu triển khai nhanh chóng và liên tục. 4. Câu chuyện về GraphQL GraphQL được sáng chế bởi Facebook. Facebook bắt đầu sử dụng GraphQL vào năm 2012 trong các ứng dụng mobile native của họ. Lần đầu tiên Facebook phát ngôn chính thức về nó là ở React.js Conf 2015 và ngay sau đó họ đã open source nó. Tại vì Facebook luôn nói về GraphQL trong bối cảnh của ReactJS nên tại thời điểm đó nhiều người chỉ nghĩ rằng GraphQL chỉ giới hạn sử dụng cho React, nhưng không phải vậy, thực tế GraphQL là một công nghệ mà có thể sử dụng mọi nơi Client giao tiếp với API. GraphQL có một cộng đồng phát triển nhanh chóng: Trước khi Facebook công bố GraphQL, thì các công ty khác như Netflix hay Coursera cũng đang phát triển những ý tưởng tương đồng với mục đích làm cho tương tác với API hiệu quả hơn. Coursera cũng đã hình dung ra một công nghệ tương tự cho phép client chỉ định những yêu cầu về dữ liệu trả về. Còn Netflix thì thậm chí cũng đã open-source giải pháp của họ gọi là Falcor. Tuy nhiên sau khi GraphQL đc open-source, Coursera đã từ bỏ nỗ lực của họ và nhảy sang dùng GraphQL. Ngày nay GraphQL được sử dụng bởi nhiều công ty khác nhau như GitHub, Twitter, Shopify, Yelp… 5. Kết luận Bài viết này mình đã giới thiệu chung về GraphQL, với mong muốn mọi người hiểu được GraphQL là gì, Tại sao nó lại ra đời. Mình cũng muốn nhấn mạnh là GraphQL là một query language cho API, nó ra đời để khắc phục những thiếu sót và nhược điểm của REST. Bài viết sau mình sẽ đi vào so sánh GraphQL và REST để làm rõ hơn sự khác nhau giữa GraphQL và REST cũng như những ưu điểm của GraphQL. Nguồn tham khảo: https://www.howtographql.com/basics/0-introduction/","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"Facebook Graph API","slug":"Facebook-Graph-API","permalink":"https://huongvnq.github.io/tags/Facebook-Graph-API/"}]},{"title":"Tìm hiểu về Var, Let và Const trong Javascript","slug":"var-let-const-javascript","date":"2020-08-31T03:23:54.000Z","updated":"2021-08-31T03:27:24.564Z","comments":true,"path":"2020/08/31/var-let-const-javascript/","link":"","permalink":"https://huongvnq.github.io/2020/08/31/var-let-const-javascript/","excerpt":"","text":"1. Lời mở đầu Như chúng ta đã biết thì ES6 mang lại cho chúng ta rất nhiều tính năng giúp cho việc viết code được rõ ràng, gọn ghẽ và tối ưu. Một trong số nhưng tính năng của của ES6 đó là bổ sung let và const cho việc khai báo biến, thay cho việc dùng var như trước đây. Trong bài viết này chúng ta sẽ đi tìm hiểu về var, let, và const đồng thời cho thấy được những điểm khác nhau giữa chúng cũng như lý do dùng cái này mà không dùng cái kia. 2. Var2.1 Scope Scope ở đây là phạm vi biến được sử dụng. Trước khi có ES6, JavaScript chỉ có 2 kiểu scope là Global Scope và Function Scope. Và một biến khai báo với var có thể có thể là global scope hoặc function scope Một biến có phạm vi là Global khi được khai báo bên ngoài một function 1234567var carName = &quot;Volvo&quot;;// code here can use carNamefunction myFunction() &#123; // code here can also use carName&#125; Biến Global có thể được truy xuất từ bất kì đâu trong một chương trình Javascipt Một biến có Function Scope khi được khai báo bên trong một Function 12345678// code here can NOT use carNamefunction myFunction() &#123; var carName = &quot;Volvo&quot;; // code here CAN use carName&#125;// code here can NOT use carNameỞ Biến Local chỉ được truy cập ở bên trong function nơi nó được khai báo. Ta xem xét ví dụ sau: 1234567var greeter = &quot;hey hi&quot;;function newFunction() &#123; var hello = &quot;hello&quot;;&#125;console.log(hello); // error: hello is not defined Ở đây, greeter là biến có phạm vi global vì nó tồn tại bên ngoài function trong khi hello có function scope. Ta sẽ không thể truy cập biến hello ở bên ngoài function. 2.2 Biến var có thể được khai báo lại và update lại Chúng ta có thể làm khai báo lại biến var như thế này ngay cả trong cùng một scope mà không có lỗi 12var greeter = &quot;hey hi&quot;;var greeter = &quot;say Hello instead&quot;; Update lại biến: 12var greeter = &quot;hey hi&quot;;greeter = &quot;say Hello instead&quot;; 2.3 Hoisting Hoisting là một cơ chế mà sự khai báo biến hay function được đưa lên đầu của scope trước khi code khai báo đó được thực thi. Ví dụ với code thế này: 12console.log(greeter);var greeter = &quot;say hello&quot;; Sẽ được biên dịch thành: 123var greeter;console.log(greeter); //greeter is undefinedgreeter = &quot;say hello&quot;; Như vậy các biến var sẽ được hoist lên đầu phạm vi và được khởi tạo một giá trị undefined 2.3 Vấn đề với Var Chúng ta sẽ xem xét đoạn code sau: 12345678var greeter = &quot;hey hi&quot;;var times = 4;if (times &gt; 3) &#123; var greeter = &quot;say Hello instead&quot;;&#125;console.log(greeter); //&quot;say Hello instead&quot; Vì times &gt; 3 nên biến greeter sẽ được định nghĩa lại là &quot;say Hello instead&quot;. SẼ có vấn đề khi mà bạn không nhớ ra rằng biến greeter đã được định nghĩa trước đó. Và ở những đoạn code khác mà bạn có sử dụng biến greeter, có thể bạn sẽ ngạc nhiên với output được đưa ra. Và nếu như code của bạn lên đến hàng nghìn dòng code thì bạn sẽ không thể biết được mình đã thay đổi giá trị của biến greeter ở đoạn nào !!! 3. Let Để giải quyết những yếu điểm của Var, ES6 mang đến cho chúng ta Let. Sau đây chúng ta hay cũng xem cách Let hoạt động như thế nào nhé. 3.1 Scope Let có phạm vi block scope Một block là đoạn code giới hạn trong cặp dấu {}. Một biến được khai báo với let trong một block thì sẽ chỉ được sử dụng trong phạm vi block đó. Ví dụ 12345678let greeting = &quot;say Hi&quot;;let times = 4;if (times &gt; 3) &#123; let hello = &quot;say Hello instead&quot;; console.log(hello); //&quot;say Hello instead&quot;&#125;console.log(hello); // hello is not defined Sử dụng biến hello bên ngoài &#123;&#125;sẽ gây ra lỗi. 3.2 Biến Let có thể được update lại nhưng không được khai báo lại. Giống như var, một biến được khai báo với let có thể được update trong phạm vi của nó. 12let greeting = &quot;say Hi&quot;;greeting = &quot;say Hello instead&quot;; Không giống như var, một biến khai báo với let không được khai báo lại trong phạm vi scope. 12let greeting = &quot;say Hi&quot;;let greeting = &quot;say Hello instead&quot;; //error: Identifier &#x27;greeting&#x27; Nếu 2 biến giống nhau được khai báo trong 2 scope khác nhau, thì sẽ không có lỗi vì trường hợp này, 2 biến sẽ được đối xử như là 2 instance khác nhau. 123456let greeting = &quot;say Hi&quot;;if (true) &#123; let greeting = &quot;say Hello instead&quot;; console.log(greeting); //&quot;say Hello instead&quot;&#125;console.log(greeting); //&quot;say Hi&quot; 3.3 Sử dụng let an toàn hơn var Let là lựa chọn tuyệt vời hơn var. Khi dùng let chúng ta k cần phải đắn đo liệu chúng ta đã sử dụng tên biến này trước đây hay chưa. Với let, biến có phạm vi block, và không thể khai báo nhiều hơn 1 lần trong cùng phạm vi, như vậy vấn đề mà ta thảo luận bên trên với var sẽ không xảy ra. 3.4 Hoisting Cũng giống var, khai báo với let cũng được hoist lên đầu scope. Tuy nhiên không giống như var, biến sẽ được khởi tạo giá trị undefined, biến khai báo với let sẽ k được khởi tạo, do đó bạn sẽ nhận về Lỗi. 1234567function checkHoisting() &#123; console.log(foo); // ReferenceError let foo = &quot;Foo&quot;; console.log(foo); // Foo&#125;checkHoisting(); 4. Const Biến được khai báo với const sẽ giữ giá trị hằng số. Khai báo với const và khai báo với let có một số điểm tương đồng. 4.1 Scope Giống như khai báo với let, khai báo với const sẽ chỉ được truy cập trong phạm vi là block nơi nó được khai báo. 4.2 Biến Const không thể được update hay khai báo lại. Biến được khai báo với const sẽ có giá trị không thay đổi trong phạm vi block. Nó sẽ không được update hay khai báo lại Cụ thể khi khai báo một cái biến với const, chúng ta không thể làm như này 12const greeting = &quot;say Hi&quot;;greeting = &quot;say Hello instead&quot;; //error : Assignment to constant variable. hay như này 12const greeting = &quot;say Hi&quot;;const greeting = &quot;say Hello instead&quot;; //error : Identifier &#x27;greeting&#x27; has already been declared Khi khai báo biến const, đồng thời cũng phải khởi tạo giá trị ngay tại thời điểm khai báo. Lưu ý: Một object được khai báo với const, object đó sẽ không thể được update tuy nhiên những thuộc tính của object này lại có thể được update lại 12345678910const greeting = &#123; message: &quot;say Hi&quot;, times: 4&#125;;const greeting = &#123; words: &quot;Hello&quot;, number: &quot;five&quot;&#125;; //error : Assignment to constant variable.greeting.message = &quot;say Hello instead&quot;; // OK. No Error 4.3 Hoisting Giống như let, khai báo const được hoist lên đầu nhưng không được khởi tạo giá trị. 5. Kết luận Bên trên mình đã trình bày những đặc điểm khi khai báo biến với var, let, và const dựa trên 3 mục chính là Scope, Được Update hay khai báo lại hay không và Hoisting. Mình xin được đúc rút những đặc điểm khác nhau giữa 3 cái như sau: Khai báo var có scope là globally hoặc function trong khi let và const có scope là block Biến khai báo với var có thể được update và khai báo lại trong phạm vi scope. Biến khai báo với let có thể được update nhưng không được khai báo lại 3 thằng đều được hoist lên đầu của scope, nhưng biến khai báo với var sẽ được khởi tạo giá trị là undefined còn biến khai báo với let và const sẽ không được khởi tạo giá trị. var và let có thể được khai báo mà không cần khởi tạo giá trị trong khi const phải được khởi tạo giá trị ngay khi khai báo. Tài liệu tham khảo: https://dev.to/sarah_chima/var-let-and-const--whats-the-difference-69e https://www.w3schools.com/js/js_let.asp","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://huongvnq.github.io/categories/Javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://huongvnq.github.io/tags/es6/"}]}],"categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://huongvnq.github.io/categories/NodeJS/"},{"name":"Magento","slug":"Magento","permalink":"https://huongvnq.github.io/categories/Magento/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://huongvnq.github.io/categories/GraphQL/"},{"name":"Javascript","slug":"Javascript","permalink":"https://huongvnq.github.io/categories/Javascript/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"https://huongvnq.github.io/tags/jwt/"},{"name":"express","slug":"express","permalink":"https://huongvnq.github.io/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://huongvnq.github.io/tags/mongodb/"},{"name":"magento basic","slug":"magento-basic","permalink":"https://huongvnq.github.io/tags/magento-basic/"},{"name":"graphql","slug":"graphql","permalink":"https://huongvnq.github.io/tags/graphql/"},{"name":"resolve","slug":"resolve","permalink":"https://huongvnq.github.io/tags/resolve/"},{"name":"API","slug":"API","permalink":"https://huongvnq.github.io/tags/API/"},{"name":"fragment","slug":"fragment","permalink":"https://huongvnq.github.io/tags/fragment/"},{"name":"SDL","slug":"SDL","permalink":"https://huongvnq.github.io/tags/SDL/"},{"name":"schema","slug":"schema","permalink":"https://huongvnq.github.io/tags/schema/"},{"name":"REST API","slug":"REST-API","permalink":"https://huongvnq.github.io/tags/REST-API/"},{"name":"Facebook Graph API","slug":"Facebook-Graph-API","permalink":"https://huongvnq.github.io/tags/Facebook-Graph-API/"},{"name":"es6","slug":"es6","permalink":"https://huongvnq.github.io/tags/es6/"}]}