<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meditation Coding</title>
  
  
  <link href="https://huongvnq.github.io/atom.xml" rel="self"/>
  
  <link href="https://huongvnq.github.io/"/>
  <updated>2021-07-21T03:43:28.857Z</updated>
  <id>https://huongvnq.github.io/</id>
  
  <author>
    <name>HuongVNQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Routing Trong Magento2</title>
    <link href="https://huongvnq.github.io/2021/07/20/routing-in-magento2/"/>
    <id>https://huongvnq.github.io/2021/07/20/routing-in-magento2/</id>
    <published>2021-07-20T05:05:37.000Z</published>
    <updated>2021-07-21T03:43:28.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/07/20/routing-in-magento2/routing.jpg" alt="routing"></p><h2 id="1-Loi-mo-dau"><a href="#1-Loi-mo-dau" class="headerlink" title="1.Lời mở đầu"></a>1.Lời mở đầu</h2><ul><li>Routing là một trong những phần rất quan trọng trong luồng hoạt động của Magento2.</li><li>Routing sẽ chịu trách nhiệm xử lý URL request, từ URL sẽ chỉ ra module nào chịu trách nhiệm xử lý request và thực thi controller action.</li><li>Trong bài viết này, chúng ta sẽ cùng đi tìm hiểu cách mà router sẽ “match” với controller action như thế nào. Sau đó sẽ tìm hiểu cách tạo một custom router. Hãy cùng đi vào nội dung của bài viết thôi nào :smile:</li></ul><h2 id="2-Magento2-Request-Flow"><a href="#2-Magento2-Request-Flow" class="headerlink" title="2.Magento2 Request Flow"></a>2.Magento2 Request Flow</h2><ul><li>Trong Magento2, một request URL sẽ như thế này<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php/front_name/controller/action</span><br></pre></td></tr></table></figure></li><li>Trong url trên, <strong>front_name</strong> sẽ được dùng để chỉ định module. <strong>Router</strong> sẽ định nghĩa cái tên này cho mỗi module trong file <strong>routes.xml</strong></li><li>Khi bạn tạo một request trong Magento2, Magento2 sẽ xử lý theo luồng như sau</li></ul><p><img src="/2021/07/20/routing-in-magento2/magento2-request-processing.png" alt="Magento2 Request Processing"></p><ul><li><strong>FrontController</strong> sẽ được gọi đến trong class Http để điều hướng request.<br>Chúng ta hãy cùng xem File <code>vendor/magento/framework/App/FrontController.php</code><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">RequestInterface <span class="variable">$request</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   \Magento\Framework\Profiler::start(<span class="string">&#x27;routers_match&#x27;</span>);</span><br><span class="line">   <span class="variable">$routingCycleCounter</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="variable">$result</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">while</span> (!<span class="variable">$request</span>-&gt;isDispatched() &amp;&amp; <span class="variable">$routingCycleCounter</span>++ &lt; <span class="number">100</span>) &#123;</span><br><span class="line">       <span class="comment">/** <span class="doctag">@var</span> \Magento\Framework\App\RouterInterface $router */</span></span><br><span class="line">       <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_routerList <span class="keyword">as</span> <span class="variable">$router</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="variable">$actionInstance</span> = <span class="variable">$router</span>-&gt;match(<span class="variable">$request</span>);</span><br><span class="line">               <span class="keyword">if</span> (<span class="variable">$actionInstance</span>) &#123;</span><br><span class="line">                   <span class="variable">$request</span>-&gt;setDispatched(<span class="literal">true</span>);</span><br><span class="line">                   <span class="keyword">$this</span>-&gt;response-&gt;setNoCacheHeaders();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="variable">$actionInstance</span> <span class="keyword">instanceof</span> \Magento\Framework\App\Action\AbstractAction) &#123;</span><br><span class="line">                       <span class="variable">$result</span> = <span class="variable">$actionInstance</span>-&gt;dispatch(<span class="variable">$request</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="variable">$result</span> = <span class="variable">$actionInstance</span>-&gt;execute();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (\Magento\Framework\<span class="built_in">Exception</span>\NotFoundException <span class="variable">$e</span>) &#123;</span><br><span class="line">               <span class="variable">$request</span>-&gt;initForward();</span><br><span class="line">               <span class="variable">$request</span>-&gt;setActionName(<span class="string">&#x27;noroute&#x27;</span>);</span><br><span class="line">               <span class="variable">$request</span>-&gt;setDispatched(<span class="literal">false</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   \Magento\Framework\Profiler::stop(<span class="string">&#x27;routers_match&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable">$routingCycleCounter</span> &gt; <span class="number">100</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">LogicException</span>(<span class="string">&#x27;Front controller reached 100 router match iterations&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Chúng ta có thể thấy ở hàm <code>dispatch</code>, router list sẽ được cho vào vòng lặp để tìm kiếm router nào sẽ match với request. Khi tìm ra controller action nào “match” với request, action đó sẽ được gọi và thực thi.</li></ul><h2 id="3-Tao-mot-custom-route-trong-area-Frontend"><a href="#3-Tao-mot-custom-route-trong-area-Frontend" class="headerlink" title="3.Tạo một custom route trong area Frontend"></a>3.Tạo một custom route trong area Frontend</h2><ul><li><p>Trước khi đi vào tạo một route, chúng ta hãy tạo một module, tham khảo bài viết <a href="/2021/07/18/create-a-new-module-in-magento2/" title="Create A New Module In Magento2">Create A New Module In Magento2</a></p></li><li><p>Ở đây mình tạo Module là Learning_Routing</p></li><li><p>Để đăng kí một frontend route, chúng ta phải tạo file routes.xml<br>File <code>app/code/Learning/Routing/etc/frontend/routes.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;urn:magento:framework:App/etc/routes.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Use router &#x27;standard&#x27; for frontend route--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router</span> <span class="attr">id</span>=<span class="string">&quot;standard&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Define a custom route with id and frontName--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">route</span> <span class="attr">frontName</span>=<span class="string">&quot;helloworld&quot;</span> <span class="attr">id</span>=<span class="string">&quot;helloworld&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--The module which this route match to--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_Routing&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">route</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Thật đơn giản để đăng kí một route. Ở đây ta phải sử dụng <strong>standard router</strong> cho area Frontend. Route này sẽ có một route con định nghĩa module cho nó và 2 attribute:</p><ul><li>Attribute <strong>id</strong> là một chuỗi unique định danh một route. Chúng ta cũng sẽ sử dụng chuỗi này để khai báo layout cho action của module.</li><li>Attribute <strong>frontName</strong> cũng là một chuỗi unique, chuỗi này được chỉ định trong url.</li></ul><p>Ví dụ nếu bạn khai báo một route như sau</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;route frontName=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt;</span><br></pre></td></tr></table></figure><p>Thì Url sẽ là</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php/helloworld/controller/action</span><br></pre></td></tr></table></figure><p>Layout cho action này sẽ là</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld_controller_action.xml</span><br></pre></td></tr></table></figure><p>Và chúng ta phải tạo controller action ở trong thư mục</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;namespace&#125;/&#123;module&#125;/Controller/&#123;Controller&#125;/&#123;Action&#125;.php</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Tao-mot-custom-route-trong-area-Admin-Admin-Route"><a href="#4-Tao-mot-custom-route-trong-area-Admin-Admin-Route" class="headerlink" title="4. Tạo một custom route trong area Admin (Admin Route)"></a>4. Tạo một custom route trong area Admin (Admin Route)</h2><ul><li><p>Route này tương tự như route cho Frontend chỉ khác là chúng ta sẽ khai báo nó trong thư mục adminhtml và với router id là <strong>admin</strong></p><p>File <code>app/code/Learning/Routing/etc/adminhtml/routes.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;urn:magento:framework:App/etc/routes.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Use router &#x27;admin&#x27; for admin route --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router</span> <span class="attr">id</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Define a custom route with id and frontName --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">route</span> <span class="attr">id</span>=<span class="string">&quot;learning_routing&quot;</span> <span class="attr">frontName</span>=<span class="string">&quot;learning_routing&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--The module which this route match to--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_Routing&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">route</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Một URL của một admin page sẽ có cấu trúc tương tự như đối với frontend page, tuy nhiên <strong>admin_area</strong> sẽ được thêm vào ở đằng trước <strong>frontName</strong> để chỉ định đây là một route của area Admin.<br>Ví dụ url của một admin csm page</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php/admin/learning_routing/controller/action</span><br></pre></td></tr></table></figure></li><li><p>Controller Action cho admin page cũng sẽ được thêm vào bên trong thư mục Controller/Adminhtml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;namespace&#125;/&#123;module&#125;/Controller/Adminhtml/&#123;Controller&#125;/&#123;Action&#125;.php</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Cach-su-dung-route-de-ghi-de-controller-cua-core"><a href="#5-Cach-su-dung-route-de-ghi-de-controller-cua-core" class="headerlink" title="5. Cách sử dụng route để ghì đè controller của core"></a>5. Cách sử dụng route để ghì đè controller của core</h2><ul><li>Như chúng ta đã thấy ở những phần bên trên, mỗi route sẽ có một <strong>id</strong> để định danh. Vậy điều gì sẽ xảy ra nếu chúng ta định nghĩa 2 route với cùng một id?</li><li>Câu trả lời là action controller sẽ tìm thấy ở cả 2 modules. Và chúng ta phải sử dụng attribute <strong>before/after</strong> để config thứ tự module, chỉ định module nào sẽ được tìm thấy trước.</li><li>Ví dụ, nếu mà chúng ta muốn ghi đè controller <code>customer/account/login</code> chúng ta sẽ định route trong <strong>route.xml</strong> như thế này:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;urn:magento:framework:App/etc/routes.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Use router &#x27;standard&#x27; for frontend route--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router</span> <span class="attr">id</span>=<span class="string">&quot;standard&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Define a custom route with id and frontName--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">route</span> <span class="attr">frontName</span>=<span class="string">&quot;helloworld&quot;</span> <span class="attr">id</span>=<span class="string">&quot;helloworld&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--The module which this route match to--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_Routing&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">route</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">route</span> <span class="attr">id</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_Routing&quot;</span> <span class="attr">before</span>=<span class="string">&quot;Magento_Customer&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">route</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>Sau đó định nghĩa một file controller :<br><code>app/code/Learning/Routing/Controller/Account/Login.php</code></li><li>Khi đó, <strong>FrontController</strong> sẽ tìm thấy action Login ở trong Module Learning_Routing trước, action này sẽ được chạy và action Login của Magento_Customer sẽ không được chạy nữa. Như vậy là chúng ta đã thực hiện ghi đè Controller thành công.</li></ul><h2 id="6-Tong-ket"><a href="#6-Tong-ket" class="headerlink" title="6. Tổng kết"></a>6. Tổng kết</h2><ul><li>Route là một phần cơ bản mà chúng ta phải biết khi tìm hiểu về luồng hoạt động của Magento. Qua bài viết này mong các bạn sẽ nắm được cách hoạt động của một route và đặc biệt là các quy tắc đặt tên để Magento có thể nhận biết và xử lý. Cảm ơn các bạn đã đọc đến cuối bài viết và hẹn gặp lại các bạn trong các bài viết tiếp theo của serries Tìm hiểu về Magento. :kissing_heart:</li><li>Nguồn tham khảo: <a href="https://www.mageplaza.com/magento-2-module-development/magento-2-routing.html">https://www.mageplaza.com/magento-2-module-development/magento-2-routing.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/07/20/routing-in-magento2/routing.jpg&quot; alt=&quot;routing&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Loi-mo-dau&quot;&gt;&lt;a href=&quot;#1-Loi-mo-dau&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Magento" scheme="https://huongvnq.github.io/categories/Magento/"/>
    
    
    <category term="magento basic" scheme="https://huongvnq.github.io/tags/magento-basic/"/>
    
  </entry>
  
  <entry>
    <title>Create A New Module In Magento2</title>
    <link href="https://huongvnq.github.io/2021/07/18/create-a-new-module-in-magento2/"/>
    <id>https://huongvnq.github.io/2021/07/18/create-a-new-module-in-magento2/</id>
    <published>2021-07-18T03:55:23.000Z</published>
    <updated>2021-07-20T02:52:16.292Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/07/18/create-a-new-module-in-magento2/module.webp" alt="magento"></p><h2 id="1-Tong-quat"><a href="#1-Tong-quat" class="headerlink" title="1.Tổng quát"></a>1.Tổng quát</h2><ul><li><p><strong>Module</strong> là một đơn vị cấu trúc của Magento. Toàn bộ hệ thống sẽ được xây dựng dựa trên các <strong>Module</strong>. Thông thường, bước đầu tiên để custom core của mangeto cũng là tạo module.</p></li><li><p>Để tạo một module, chúng ta phải thực hiện các bước sau:</p><ul><li>Tạo một thư mục <strong>module</strong></li><li>Tạo file etc/module.xml</li><li>Tạo file registration.php</li><li>Chạy <code>script bin/magento setup:upgrade</code> để install module mới</li><li>Kiểm tra module được active hay chưa.</li></ul></li></ul><pre><code>chúng ta hãy cùng đi vào cụ thể từng bước nhé.</code></pre><h2 id="2-Tao-thu-muc-cho-module"><a href="#2-Tao-thu-muc-cho-module" class="headerlink" title="2. Tạo thư mục cho module"></a>2. Tạo thư mục cho module</h2><ul><li>Chúng ta có 2 nơi để tạo thư mục cho module. Đó là trong folder <code>app/code</code> và trong folder <code>vendor</code>.</li><li>Tuỳ thuộc vào cách cài đặt Magento2, những module core của magento có thể được đặt trong các thư mục <code>vendor/magento/magento-*</code> (trường hợp dùng composer để install) hoặc <code>app/code/Magento/</code> (trường hợp clone Github)</li><li>Vậy chúng ta nên đặt module mới ở đâu?<ul><li>Nếu chúng ta build một module cho một project cụ thể, chúng ta sẽ tạo mới module ở trong thư mục <code>app/code</code> và commit lên repository của product trên Github.</li><li>Nếu chúng ta xây dựng một extension để tái sử dụng, chúng ta sẽ dùng <code>composer</code> để tạo nó và chúng ta sẽ đặt module ở trong <code>vendor/&lt;YOUR_VENDOR&gt;/module-something</code></li></ul></li><li>Tên của module trong magento2 sẽ bao gồm 2 phần: tên vendor và tên của chính module đó. Nói cách khác, module sẽ được nhóm lại thành 1 vendor do vậy khi đặt tên của module ta phải chỉ định cả tên vendor đó.</li><li>Trong ví dụ này chúng ta sẽ tạo một vendor là <code>Learning</code> và một module là <code>First Unit</code><ul><li><code>cd</code> to folder root</li><li><code>mkdir app/code/Learning</code></li><li><code>mkdir app/code/Learning/FirstUnit</code></li></ul></li></ul><h2 id="3-Tao-file-etc-module-xml"><a href="#3-Tao-file-etc-module-xml" class="headerlink" title="3. Tạo file etc/module.xml"></a>3. Tạo file etc/module.xml</h2><ul><li>Trước tiên chúng ta phải đảm bảo rằng chúng ta có quyền để tạo file và folder trong folder root nhé.</li><li>Nếu đã có quyền, chúng ta tạo một file <code>etc/module.xml</code>. Phải có file này thì module mới tồn tại được.</li><li>File module.xml chứa các thông tin sau<ul><li>Module name</li><li>Module version</li><li>Dependencies</li></ul></li><li><strong>Module name</strong> đã được định nghĩa bằng tên thư mục mà chúng ta vừa tạo.</li><li>Trong Magento2, tất cả các class name phải tuân theo cấu trúc thư mục. Bởi vì chúng ta tạo thư mục là <code>Learning/FirstUnit</code> nên module name của chúng ta sẽ là <code>Learning_FirstUnit</code>.</li><li>Tất cả các class thuộc module này sẽ là bắt đầu với <code>Learning/FirstUnit</code><br>Ví dụ <code>Learning\FirstUnit\Observer\Test</code></li><li>Tiếp theo đến <strong>Module version</strong>. Module version cho biết được phiên bản hiện tại của <strong>database schema</strong> và <strong>data</strong>, được sử dụng cho việc upgrade module.</li><li>Ví dụ như giả định bạn muốn thay đổi cấu trúc bảng dữ liệu (database table schema) của module này. Làm thế nào để bạn đảm bảo rằng thay đổi này sẽ được áp dụng trên tất cả các phiên bản mã code đã được deploy rồi.</li><li>Magento sẽ có các <strong>script install</strong> và <strong>upgrade</strong> cho mỗi module (Hoặc bạn tự tạo). Các file script này sẽ có các command để thay đổi database schema và data.</li><li>Để theo dõi xem liệu đã thực thi phần lệnh trong script hay chưa, magento sẽ track dựa vào <strong>module version</strong>. Mỗi lần bạn thực thi thay đổi mới trong database, bạn sẽ phải thực thi với version mới của module và tăng version của module lên tương ứng trong file module.xml.</li><li>Magento sẽ lưu phiên bản hiện tại của module trong database. Nếu giá trị trong database và trong file module.xml không khớp với nhau, nó sẽ thực thi <strong>upgrade</strong> code.</li><li><strong>Dependencies</strong>: Nếu một module phụ thuộc vào một module khác thì chúng ta phải khai báo trong file modules.xml danh sách các module mà module hiện tại của chúng ta đang phụ thuộc vào. Ví dụ, module này chúng ta tạo ra sẽ phụ thuộc vào module Magento_Catalog.</li><li>Đầu tiên chúng ta tạo folder etc:<br><code>mkdir app/code/Learning/FirstUnit/etc</code></li><li>Tạo file module.xmll<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;urn:magento:framework:Module/etc/module.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_FirstUnit&quot;</span> <span class="attr">setup_version</span>=<span class="string">&quot;0.0.1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Magento_Catalog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Trong file module mà chúng ta vừa tạo, chúng ta đã chỉ định:<ul><li>Module name: <code>Learning_FirstUnit</code> dựa trên folder mà chúng ta đã tạo.</li><li>Versionn: <code>0.0.1</code> (Version khởi tạo của module)</li><li>Dependency: <code>Magento_Catalog</code>. Chúng ta có thể có nhiều Dependency, khi ấy chúng ta hãy liệt kê bằng các thẻ <code>&lt;module name=&quot;...&quot; /&gt;</code> ở bên trong thẻ <code>&lt;sequence&gt;</code></li></ul></li></ul><h2 id="4-Tao-file-registration-php"><a href="#4-Tao-file-registration-php" class="headerlink" title="4. Tạo file registration.php"></a>4. Tạo file registration.php</h2><ul><li>Mỗi module sẽ phải có file này để đăng kí cho magento biết vị trí của module. Tiếp tục example, chúng ta sẽ tạo file <code>app/code/Learning/FirstUnit/registration.php</code><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> \Magento\Framework\Component\ComponentRegistrar::register(</span><br><span class="line">\Magento\Framework\Component\ComponentRegistrar::MODULE, <span class="string">&#x27;Learning_FirstUnit&#x27;</span>,</span><br><span class="line"><span class="keyword">__DIR__</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>File <strong>registrationn.phpp</strong> sẽ giống nhau đối với tất cả các module, chỉ khác tên của module, ở đây của chúng ta là <code>Learning_FirstUnit</code></li></ul><h2 id="5-Chay-command"><a href="#5-Chay-command" class="headerlink" title="5. Chạy command"></a>5. Chạy command</h2><ul><li>Tạo xong module chúng ta phải chạy command để active module, để thông báo cho magento biết về sự hiện diện của nó.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php bin/magento setup:upgrade</span><br></pre></td></tr></table></figure></li><li>Câu lệnh sẽ cho ra rất nhiều dòng input, hãy check xem một trong các dòng đó có <code>Learning_FirstUnit</code> hay không.</li></ul><h2 id="6-Check-module-is-active"><a href="#6-Check-module-is-active" class="headerlink" title="6 Check module is active"></a>6 Check module is active</h2><ul><li>Mặc dù chúng ta chưa add những logic code vào module, trong ví dụ này chúng ta chỉ thực hiện tạo module, module hiện taị đang trống và không thể nhìn thấy được.</li><li>Để kiểm tra module đã được nhận hay chưa, chúng ta hãy kiểm tra file <code>app/etc/config.php</code>, file này chứa tất cả các module đã được active. Chúng cũng không được thay đổi file này một cách thủ công.</li><li>Check module is active</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep Learning_FirstUnit app/etc/config.php</span><br></pre></td></tr></table></figure><h2 id="7-Ket-luan"><a href="#7-Ket-luan" class="headerlink" title="7. Kết luận."></a>7. Kết luận.</h2><ul><li>Lại là một bài viết đơn giản siêu siêu beginer cho các bạn mới mày mò tìm hiểu magento, thực hiện các bước trong bài viết, các bạn đã có thể tạo cho mình một module để bắt đầu có thể add những logic phực tạp hơn cho module trong magento. Mong bài viết sẽ có ích đối với các bạn và hãy đón chờ các bài viết tiếp theo của mình trong serries về Magento nhé. Ciao!</li><li>Bài viết tham khảo <a href="https://devdocs.magento.com/videos/fundamentals/create-a-new-module/">https://devdocs.magento.com/videos/fundamentals/create-a-new-module/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/07/18/create-a-new-module-in-magento2/module.webp&quot; alt=&quot;magento&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Tong-quat&quot;&gt;&lt;a href=&quot;#1-Tong-quat&quot; class=&quot;</summary>
      
    
    
    
    <category term="Magento" scheme="https://huongvnq.github.io/categories/Magento/"/>
    
    
    <category term="magento basic" scheme="https://huongvnq.github.io/tags/magento-basic/"/>
    
  </entry>
  
  <entry>
    <title>Create A New Page In Magento2</title>
    <link href="https://huongvnq.github.io/2021/07/17/create-a-new-page-in-magento2/"/>
    <id>https://huongvnq.github.io/2021/07/17/create-a-new-page-in-magento2/</id>
    <published>2021-07-17T07:06:27.037Z</published>
    <updated>2021-07-20T04:41:33.122Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/07/17/create-a-new-page-in-magento2/magento.png" alt="magento"></p><h2 id="1-Tong-quan"><a href="#1-Tong-quan" class="headerlink" title="1. Tổng quan"></a>1. Tổng quan</h2><ul><li>Mở đầu series chia sẻ về Magento lần này, mình sẽ trình bày cách tạo một page mới trong magnento. Chúng ta sẽ cùng tạo một page mới trả về JSON với một tham số “HELLO WORLD!” nhé. :D</li><li>Để thêm một page mới trong magento2, chúng ta phải tạo một <strong>controller</strong>.</li><li>Trong Magento2, một controller là một file được đặt ở một nơi được quy định để magento có thể hiểu và response một <strong>route</strong> tương ứng.</li><li>Một route trong Magento2 là một URL tiêu chuẩn bao gồm 3 phần:<ul><li><strong>frontName</strong></li><li><strong>controllerName</strong></li><li><strong>actionName</strong></li></ul></li></ul><pre><code>Chúng ta sẽ đi vào tìm hiểu magento sẽ dựa vào 3 phần này của route như thế nào để tương ứng với một file nhất định.</code></pre><ul><li><p>Các bước để tạo một new page:</p><ul><li>Tạo một module mới.</li><li>Tạo file routes.xml</li><li>Tạo file controller (action)</li></ul><p>Chúng ta hãy cùng đi vào cụ thể từng bước nhé. :D</p></li></ul><h2 id="2-Tao-mot-module-moi"><a href="#2-Tao-mot-module-moi" class="headerlink" title="2. Tạo một module mới"></a>2. Tạo một module mới</h2><ul><li>Để tạo một module, bạn cần làm theo các bước sau:<ul><li>Tạo một folder cho module.</li><li>Tạo file etc/module.xml</li><li>Tạo file registration.php</li><li>Chạy lệnh <code>bin/magento setup:upgrade</code></li></ul></li><li>Thực hành luôn, chúng ta sẽ tạo một thư mực module tên là Learning_HelloPage<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &lt;magento2_root&gt;/app/code</span><br><span class="line">$ mkdir Learning</span><br><span class="line">$ mkdir Learning/HelloPage</span><br></pre></td></tr></table></figure></li><li>Tạo file registration.php<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">\Magento\Framework\Component\ComponentRegistrar::register( \Magento\Framework\Component\ComponentRegistrar::MODULE, <span class="string">&#x27;Learning_HelloPage&#x27;</span>,</span><br><span class="line"><span class="keyword">__DIR__</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>Tạo file module.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;urn:magento:framework:Module/etc/module.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_HelloPage&quot;</span> <span class="attr">setup_version</span>=<span class="string">&quot;0.0.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>Như vậy là chúng ta đã tạo xong một module mới. Về Quy tắc đặt tên, cấu trúc thư mục, ý nghĩa của các file registration.php, module.xml mình sẽ trình bày cụ thể trong bài viết tiếp theo.</li></ul><h2 id="3-Tao-file-routes-xml"><a href="#3-Tao-file-routes-xml" class="headerlink" title="3. Tạo file routes.xml"></a>3. Tạo file routes.xml</h2><ul><li>Trước khi đi vào tạo file routes.xml, chúng ta hãy cùng tìm hiểu xem một route hoạt động thế nào trong magento2 nhé.</li><li>Magento có các <strong>area</strong>, chẳng hạn như <strong>admin</strong> - liên quan đến việc hiện thị bên trang admin, <strong>frontend</strong> liên quan đến việc hiện thị giao diện phía người dùng.</li><li>Mỗi một area sẽ có một file routes.xml được merge từ các file <code>etc/area/routes.xml</code> từ tất cả các module.</li><li>File route.xml sẽ chứa tất cả các thông tin về route đựợc đăng kí và <strong>frontName</strong>. Lưu ý rằng <strong>frontName</strong> sẽ là phần đầu của một route.</li><li>Để dễ hiểu hơn chúng ta hãy đi vào thực hành nhé. Bởi vì chúng ta đang tạo một page return về JSON cho user, tức là đang trong frontend area. Do đó chúng ta sẽ tạo một file <code>ect/frontend/routes.xml</code> cho module <code>Learning_HelloPage</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;urn:magento:framework:App/etc/routes.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router</span> <span class="attr">id</span>=<span class="string">&quot;standard&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">route</span> <span class="attr">id</span>=<span class="string">&quot;learning&quot;</span> <span class="attr">frontName</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">module</span> <span class="attr">name</span>=<span class="string">&quot;Learning_HelloPage&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">route</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Chúng ta vừa thêm một route tên là <code>learning</code>.Lưu ý là tên của route không nhất thiết phải trùng với tên của module.</li><li>frontName mà chúng ta tạo lfa <code>test</code>. Thông thường tên route và frontName là giống nhau nhưng cũng không bắt buộc phải vậy.</li><li>Khi magento xử lý một route <code>test/chunk2/chunk3</code>, magento sẽ kiểm tra liệu trong thư mục module <code>Learning_HelloPage</code> có thư mục <code>Controller/Chunk2</code> hay không. Tiếp đến trong thư mục Chunk2 có action file <code>Chunk3</code> hay không.</li><li>Ở đây route của chúng ta sẽ là <code>test/page/view</code>. Chúng ta hãy cùng tạo file Controller để magento có thể hiểu và lấy làm file xử lý route này nhé.</li></ul><h2 id="4-Tao-file-controller-file-action"><a href="#4-Tao-file-controller-file-action" class="headerlink" title="4. Tạo file controller (file action)"></a>4. Tạo file controller (file action)</h2><ul><li><p>Như đã nó ở bên trên, với route <code>test/page/view</code>, Magento sẽ tìm đến thư mục Controller/Page, tiếp đó tìm đến file View.php</p></li><li><p>Chúng ta thêm controller như sau:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;magento2_root&gt;/app/code/Learning/HelloPage</span><br><span class="line">$ mkdir Controller</span><br><span class="line">$ mkdir Controller/Page</span><br></pre></td></tr></table></figure><p>Tạo action file <code>Controller/Page/View.php</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright © 2016 Magento. All rights reserved.</span></span><br><span class="line"><span class="comment"> * See COPYING.txt for license details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Learning</span>\<span class="title">HelloPage</span>\<span class="title">Controller</span>\<span class="title">Page</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">extends</span> \<span class="title">Magento</span>\<span class="title">Framework</span>\<span class="title">App</span>\<span class="title">Action</span>\<span class="title">Action</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \Magento\Framework\Controller\Result\JsonFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$resultJsonFactory</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Magento\Framework\App\Action\Context $context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Magento\Framework\Controller\Result\JsonFactory $resultJsonFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">       \Magento\Framework\App\Action\Context <span class="variable">$context</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       \Magento\Framework\Controller\Result\JsonFactory <span class="variable">$resultJsonFactory</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">$this</span>-&gt;resultJsonFactory = <span class="variable">$resultJsonFactory</span>;</span><br><span class="line">       <span class="built_in">parent</span>::__construct(<span class="variable">$context</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * View  page action</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Magento\Framework\Controller\ResultInterface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="variable">$result</span> = <span class="keyword">$this</span>-&gt;resultJsonFactory-&gt;create();</span><br><span class="line">       <span class="variable">$data</span> = [<span class="string">&#x27;message&#x27;</span> =&gt; <span class="string">&#x27;Hello world!&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$result</span>-&gt;setData(<span class="variable">$data</span>);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>Việc còn lại là active module và page của chúng ta bằng cách chạy câu lệnh <strong>Magento setup uprade</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;magento2_root&gt;</span><br><span class="line">$ php bin/magento setup:upgrade</span><br></pre></td></tr></table></figure></li><li><p>Đến đây chúng ta có thể test page của chúng ta bằng cách gõ đường link <code>/test/page/view</code>. Chúng ta sẽ nhìn thấy message hiện lên trên trang</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Ở bài viết này chủ yếu đi vào cách tạo một page mới nên chúng ta xây dựng một trang trả về một <strong>ResultJson</strong>. Ngoài ra magento2 có rất nhiều kiểu Result Object cho các trừờng hợp khác như ResultPage, Forward Result…</p></li></ul><h2 id="5-Tong-ket"><a href="#5-Tong-ket" class="headerlink" title="5. Tổng kết."></a>5. Tổng kết.</h2><ul><li>Bài viết là một bài cơ bản, đơn giản về cách tạo một page trong Magento2. Mong bài viết sẽ hữu ích cho các bạn beginner bắt đầu mày mò nghiên cứu về magento. Mình cũng mới dấn thân vào con đường Magento nên mong các bạn góp ý cho bài viết và hãy cùng mình học tập tìm hiểu về magento trong những bài viết tiếp theo nhé. see ya!</li><li>Bài viết tham khảo <a href="https://devdocs.magento.com/videos/fundamentals/create-a-new-page/">https://devdocs.magento.com/videos/fundamentals/create-a-new-page/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/07/17/create-a-new-page-in-magento2/magento.png&quot; alt=&quot;magento&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Tong-quan&quot;&gt;&lt;a href=&quot;#1-Tong-quan&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Magento" scheme="https://huongvnq.github.io/categories/Magento/"/>
    
    
    <category term="magento basic" scheme="https://huongvnq.github.io/tags/magento-basic/"/>
    
  </entry>
  
  <entry>
    <title>Thực thi truy vấn GraphQL trên Server</title>
    <link href="https://huongvnq.github.io/2021/04/21/graphql-server-execution/"/>
    <id>https://huongvnq.github.io/2021/04/21/graphql-server-execution/</id>
    <published>2021-04-21T04:46:57.000Z</published>
    <updated>2021-07-23T04:49:06.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Gioi-thieu-chung"><a href="#1-Gioi-thieu-chung" class="headerlink" title="1. Giới thiệu chung"></a>1. Giới thiệu chung</h1><ul><li><p>Khi Client gọi các câu truy vấn GraphQL, các câu truy vấn này sẽ trải qua quá trình validation dựa vào <strong>Type System</strong> (<strong>Schema</strong>).</p></li><li><p>Nếu câu truy vấn là hợp lệ, nó sẽ được thực thi bởi GraphQL Server, sau đó server sẽ trả về kết quả mang “hình dáng” của câu query mà Client yêu cầu, kết quả trả về là kiểu Json.</p></li><li><p>GraphQL không thể thực thi Query mà không có Schema. Chúng ta hãy cùng sử dụng ví dụ Schema sau để minh họa việc thực thi một truy vấn.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  human(id: ID!): Human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Human &#123;</span><br><span class="line">  name: String</span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line">  starships: [Starship]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Starship &#123;</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Để mô tả điều gì xảy ra khi một query được thực thi, chúng ta hãy thực hiện một câu query phía client như sau</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: 1002) &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">    starships &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kết quả server trả về như sau</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;human&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;appearsIn&quot;</span>: [<span class="string">&quot;NEWHOPE&quot;</span>, <span class="string">&quot;EMPIRE&quot;</span>, <span class="string">&quot;JEDI&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;starships&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Millenium Falcon&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Imperial shuttle&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Mỗi một trường trong query như là một function hay method của type cha để trả về type con. Chẳng hạn như <code>name</code> là một function của type human để trả về type name của human.</p></li><li><p>Mỗi field trên mỗi type có một function chịu trách nhiệm xử lý phía backend gọi là <strong>resolver</strong>. Khi một field được thực thi, resolver tương ứng sẽ được gọi để trả về value cho các filed con tiếp theo.</p></li><li><p>Nếu một field là một loại <strong>scalar</strong> như là một string hay một number, thì việc thực thi hoàn thành.</p></li><li><p>Còn nếu một field trả về một object value, thì việc thực thi sẽ lại được tiếp tục trên các field của object đó, cứ tiếp tục như vậy cho đến khi đạt được các scalar value. GraphQL Query luôn luôn kết thúc ở các scalar value.</p></li></ul><h1 id="2-Root-fields-amp-Resolvers"><a href="#2-Root-fields-amp-Resolvers" class="headerlink" title="2. Root fields &amp; Resolvers"></a>2. Root fields &amp; Resolvers</h1><ul><li>Ở level cao nhất của một GraphQL Server chính là <strong>Root type</strong> hay còn gọi <strong>Query type</strong>, nó đại diện cho các entry point của GraphQL API.</li><li>Ở ví dụ dưới đây, Query type định nghĩa một field <code>human</code> nhận vào tham số là id. Trên server, định nghĩa một function resolver cho field <code>human</code> này, function này đại khái sẽ truy xuất database lấy ra dữ liệu, khởi tạo và trả về một đối tượng <code>Human</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Query: &#123;</span><br><span class="line">  human(obj, args, context, info) &#123;</span><br><span class="line">    return context.db.loadHumanByID(args.id).then(</span><br><span class="line">      userData =&gt; new Human(userData)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Ví dụ bên trên được viết với ngôn ngữ JavaScript, tuy nhiên bạn có thể xây dựng một GraphQL Server bằng nhiều ngôn ngữ khác. Tuy nhiên dù thế nào thì một resolver function sẽ nhận vào 4 tham số<ul><li><strong>obj</strong>: Đối tượng trả về từ field cha.</li><li><strong>args</strong>: Một object chứa tất cả các tham số GraphQL cung cấp cho field này.</li><li><strong>context</strong>: Một object chia sẻ giữa tất cả các resolver bao gồm các thông tin liên quan đến ngữ cảnh như thông tin người dùng đăng nhập, kết nối cơ sở dữ liệu …</li><li><strong>info</strong></li></ul></li></ul><h1 id="3-Trivial-Resolvers-Nhung-ham-resolver-“easy-to-solve”"><a href="#3-Trivial-Resolvers-Nhung-ham-resolver-“easy-to-solve”" class="headerlink" title="3. Trivial Resolvers (Những hàm resolver “easy to solve”)"></a>3. Trivial Resolvers (Những hàm resolver “easy to solve”)</h1><ul><li>Khi object <code>Human</code> được trả về cho trường <code>human</code>, GraphQL sẽ thực thi tiếp cho những field là field con của field <code>human</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Human: &#123;</span><br><span class="line">  name(obj, args, context, info) &#123;</span><br><span class="line">    return obj.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>GraphQL mạnh mẽ với hệ thống type system được định nghĩa trước, được sử dụng để GraphQL quyết định cái gì làm tiếp theo.</li><li>Thậm chí, trước cả khi <code>human</code> field return bất cứ cái gì, GraphQL cũng biết bước tiếp theo là resolve những field của <code>Human</code> bởi vì type system sẽ nói cho GraphQL biết rằng fielđ <code>human</code> sẽ trả về <code>Human</code></li><li>Việc giải quyết cho trường <code>name</code> trong ví dụ bên trước rất là đơn giản, rõ ràng. Function resolver cho trường name được gọi, ở đây <code>obj</code> chính là object <code>new Human</code> trả về từ field đằng trước (field cha, field <code>human</code>). Function sẽ chả về trường name truy vấn trên đối tượng <code>obj</code></li><li><strong>Lưu ý</strong> : Trong thực tế nhiều thư viện GraphQL sẽ bỏ đi những hàm resolver đơn giản như trên. Nếu hàm resolver được chỉ đinh, GraphQL sẽ thực thi hàm resolver đó, nếu không thì GraphQL sẽ ngầm hiểu để đọc và trả về một trường cùng tên (cụ thể trong ví dụ trên, GraphQL sẽ ngầm hiểu và trả về trường name của object <code>Human</code> cho field name là field con của field <code>Human</code>).</li></ul><h1 id="4-Scalar-coercion-cuong-che-vo-huong"><a href="#4-Scalar-coercion-cuong-che-vo-huong" class="headerlink" title="4. Scalar coercion (cưỡng chế vô hướng)"></a>4. Scalar coercion (cưỡng chế vô hướng)</h1><ul><li>Trong khi field <code>name</code> được resolve, thì các field <code>appearsIn</code> và <code>starships</code> cũng được thực thi đồng thời. Hàm thực thi của field <code>appearsIn</code> có thể cũng là một hàm trivival resolver<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Human: &#123;</span><br><span class="line">  appearsIn(obj) &#123;</span><br><span class="line">    return obj.appearsIn // returns [ 4, 5, 6 ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Ở đây chú ý rằng, type system đã yêu cầu <code>appearsIn</code> phải trả về kiểu Enum <code>Episode</code>. Tuy nhiên function resolver lại return về numbers!</li><li>Điều hay ho ở đây là chúng ta hãy xem lại kết quả trả về cho client đã được show ở phần đầu của bài viết, chúng ta sẽ thấy kết quả trả về sẽ tương ứng với các giá trị của Enum</li><li>Đây là một ví dụ về <strong>Scalar Coercion</strong>. Type System sẽ dựa vào schema để biết được cái gì được mong đợi trả về và sẽ convert giá trị trả về bởi resolver để phù hợp với “hợp đồng”</li></ul><h1 id="5-Ket-qua-tra-ve-cho-client"><a href="#5-Ket-qua-tra-ve-cho-client" class="headerlink" title="5. Kết quả trả về cho client."></a>5. Kết quả trả về cho client.</h1><ul><li>Khi mỗi field được resolve, kết quả sẽ được trả về theo định dạng key-value. Key là tên field hoặc alias, value là giá trị trả về của resolver</li><li>Kết quả sẽ theo đúng cấu trúc mà client yêu cầu trong truy vấn truyền lên.</li></ul><h1 id="6-Ket-luan"><a href="#6-Ket-luan" class="headerlink" title="6. Kết luận"></a>6. Kết luận</h1><ul><li>Ở bài viết này mình đã trình bày tổng quan về các mà GraphQL server thực hiện để đáp ứng yêu cầu phía Client. Nói chung GraphQL Server phải định nghĩa các hàm resolver để xử lý trả về dữ liệu cho các <strong>field</strong> (từ <strong>Root field</strong> đến các field con)</li><li>Mong bài viết sẽ truyền đạt được nội dung một cách ngắn gọn nhất đến các bạn và mong nhận được góp ý nếu có chỗ nào chưa chính xác.</li><li>Nguồn tham khảo <a href="https://graphql.org/learn/execution/">https://graphql.org/learn/execution/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Gioi-thieu-chung&quot;&gt;&lt;a href=&quot;#1-Gioi-thieu-chung&quot; class=&quot;headerlink&quot; title=&quot;1. Giới thiệu chung&quot;&gt;&lt;/a&gt;1. Giới thiệu chung&lt;/h1&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="resolve" scheme="https://huongvnq.github.io/tags/resolve/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL Fragment</title>
    <link href="https://huongvnq.github.io/2021/03/20/graphql-fragment/"/>
    <id>https://huongvnq.github.io/2021/03/20/graphql-fragment/</id>
    <published>2021-03-20T04:40:46.000Z</published>
    <updated>2021-07-23T04:45:33.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/20/graphql-fragment/graphql-fragment.webp" alt="GraphQL Fragment"></p><h1 id="1-Fragment-trong-GraphQL-la-gi"><a href="#1-Fragment-trong-GraphQL-la-gi" class="headerlink" title="1. Fragment trong GraphQL là gì?"></a>1. Fragment trong GraphQL là gì?</h1><ul><li>Trong GraphQL có một khái niệm hay được sử dụng là <strong>Fragment</strong>. Trong bài viết ngày hôm nay chúng ta hãy cùng đi tìm hiểu khái niệm này là như thế nào nhé.</li><li>Một GraphQL Fragment là một phần tử có thể tái sử dụng trong <strong>GraphQL Query</strong>.</li><li>Trong GraphQL sẽ có những lúc bạn gặp phải những tình huống mà bạn cần phải query các <strong>field</strong> giống nhau trong các câu query khác nhau. Khi mà bạn nhận thấy các câu query của bạn có nhiều các field bị lặp lại tại nhiều vị trí khác nhau. Bạn có thể tóm chúng lại thành một đơn vị có thể tái sử dụng gọi là <strong>Fragment</strong>.</li><li>Một GraphQL Fragment cho phép bạn khai báo một bộ các field và sử dụng chúng trong nhiều câu query. Bạn có thể liên tưởng <strong>Fragment</strong> trong GraphQL có nét tương đồng như là <strong>function</strong> trong nhiều ngôn ngữ lập trình. Bạn khai báo function ở một chỗ và bạn gọi đến function ở nhiều chỗ dùng đến nó. Chúng đều là các phần tử tái sử dụng được.</li></ul><h1 id="2-Cac-thanh-phan-cua-mot-Fragment"><a href="#2-Cac-thanh-phan-cua-mot-Fragment" class="headerlink" title="2. Các thành phần của một Fragment"></a>2. Các thành phần của một Fragment</h1><ul><li>Chúng ta hãy đi vào tìm hiểu các thành phần của một Fragment với cấu trúc mẫu bên dưới<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fragment Name on TypeName &#123;</span><br><span class="line">  field1</span><br><span class="line">  field2</span><br><span class="line">  field3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Một Fragment sẽ bao gồm 3 thành phần sau<ul><li>Name: Tên riêng biệt cho 1 Fragment (mỗi một Fragment có 1 tên riêng)</li><li>TypeName: Kiểu của object trong <strong>GraphQL Schema</strong> mà Fragment được tạo ra từ đó, hay được lồng trong đó</li><li>Body: Body của Fragment định nghĩa các trường nào sẽ được query (field1, field2, field3)</li></ul></li></ul><h1 id="3-Loi-ich-cua-viec-su-dung-GraphQL-Fragment"><a href="#3-Loi-ich-cua-viec-su-dung-GraphQL-Fragment" class="headerlink" title="3. Lợi ích của việc sử dụng GraphQL Fragment"></a>3. Lợi ích của việc sử dụng GraphQL Fragment</h1><p>Tại sao Fragment lại là một khái niệm rất “cool” trong GraphQL</p><ul><li>Thứ nhất, bởi tính tái sử dụng của Fragment: Với Fragment, bạn có thể cấu trúc các câu query của bạn thành các phần tử có thể sử dụng được ở nhiều chỗ mà không cần phải viết lặp đi lặp lại.</li><li>Caching: <strong>GraphQL Client</strong> tận dụng các <strong>Fragment</strong> để cung cấp các option caching. Xem thêm apollographql.com/docs/react/caching/cache-interaction/</li></ul><h1 id="4-Tao-GraphQL-Fragment"><a href="#4-Tao-GraphQL-Fragment" class="headerlink" title="4. Tạo GraphQL Fragment"></a>4. Tạo GraphQL Fragment</h1><ul><li>Chúng ta hãy cùng học cách tạo một GraphQL Fragment qua một vài ví dụ nhé. Trong những ví dụ trong bài viết này, mình sử dụng <a href="https://docs.github.com/en/graphql">Github’s public API</a> và viết query dựa trên nó. Bạn cũng có thể chạy các câu query trên <a href="https://docs.github.com/en/graphql/overview/explorer">Github GraphQL Explorer</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  googleRepo: repository(owner: &quot;google&quot;, name: &quot;WebFundamentals&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    owner &#123;</span><br><span class="line">      id</span><br><span class="line">      avatarUrl</span><br><span class="line">      resourcePath</span><br><span class="line">      url</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  facebookRepo: repository(owner: &quot;facebook&quot;, name: &quot;react&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    owner &#123;</span><br><span class="line">      id</span><br><span class="line">      avatarUrl</span><br><span class="line">      resourcePath</span><br><span class="line">      url</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Chúng ta nhận thấy ở đây là chúng ta đang query cùng các field bên trong field <code>owner</code> nhiều lần. Đây là lúc thích hợp để chúng ta sử dụng <strong>Fragment</strong></li><li>Chúng ta sẽ tạo một fragment gọi là <code>ownerInfo</code> với từ khoá <code>fragment</code>. Để tạo một Fragment chúng ta phải nói cho GraphQL biết rằng Fragment này được tạo ra trên <strong>field</strong> nào. Trong trường hợp này, chúng ta sẽ tạo 1 Fragment trên field<code>RepositoryOwner</code></li><li>Trong Body của Fragment, chúng ta có thể bao gồm tất cả các field của đối tượng <code>RepositoryOwner</code>. Ở đây chúng ta định nghĩa các field là <code>id</code>, <code>avatarUrl</code>, <code>resourcePath</code>, <code>url</code> là các field của fragment <code>ownerInfo</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// fragment ownerInfo for RepositoryOwner fields</span><br><span class="line">fragment ownerInfo on RepositoryOwner &#123;</span><br><span class="line">  id</span><br><span class="line">  avatarUrl</span><br><span class="line">  resourcePath</span><br><span class="line">  url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-Su-dung-mot-GraphQL-Fragment"><a href="#5-Su-dung-mot-GraphQL-Fragment" class="headerlink" title="5. Sử dụng một GraphQL Fragment"></a>5. Sử dụng một GraphQL Fragment</h1><ul><li><p>Chúng ta có thể sử dụng Fragment mà chúng ta sử dụng ở ví dụ trước trong phạm vi một query bằng việc sử dụng toán tử <code>...</code> và theo sau là tên của Fragment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// GraphQL Query with fragments</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  googleRepo: repository(owner: &quot;google&quot;, name: &quot;WebFundamentals&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    owner &#123;</span><br><span class="line">      ...ownerInfo //fragment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  facebookRepo: repository(owner: &quot;facebook&quot;, name: &quot;react&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    owner &#123;</span><br><span class="line">     ...ownerInfo //fragment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Response của query khi chúng ta sử dụng Fragment sẽ không thay đổi so với khi chúng ta không sử dụng Fragment. Fragment chỉ đơn giản là làm cho câu query được clean hơn, dễ đọc, và tái sử dụng</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GraphQL JSON Response</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;googleRepo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;WebFundamentals&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;owner&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ=&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;avatarUrl&quot;</span>: <span class="string">&quot;https://avatars1.githubusercontent.com/u/1342004?v=4&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;resourcePath&quot;</span>: <span class="string">&quot;/google&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/google&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;facebookRepo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;owner&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;avatarUrl&quot;</span>: <span class="string">&quot;https://avatars3.githubusercontent.com/u/69631?v=4&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;resourcePath&quot;</span>: <span class="string">&quot;/facebook&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/facebook&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="6-Ket-luan"><a href="#6-Ket-luan" class="headerlink" title="6. Kết luận"></a>6. Kết luận</h1><ul><li>Fragment là một khái niệm rất thú vị trong GraphQL, nó cho phép tái sử dụng trong khi viết các câu query, loại bỏ các đoạn mã phải viết đi viết lại, giúp các câu query dễ đọc dễ hiểu hơn. Mong qua bài viết này, các bạn sẽ hiểu hơn về khái niệm Fragment và có thể sử dụng Fragment khi viết GraphQL Schema cũng như không bỡ ngỡ mỗi khi đọc Schema có sử dụng Fragment</li><li>Nguồn tham khảo<ul><li><a href="https://blog.logrocket.com/graphql-fragments-explained/">https://blog.logrocket.com/graphql-fragments-explained/</a></li><li><a href="https://graphql.org/learn/queries/#fragments">https://graphql.org/learn/queries/#fragments</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/03/20/graphql-fragment/graphql-fragment.webp&quot; alt=&quot;GraphQL Fragment&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Fragment-trong-GraphQL-la-gi&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="API" scheme="https://huongvnq.github.io/tags/API/"/>
    
    <category term="fragment" scheme="https://huongvnq.github.io/tags/fragment/"/>
    
    <category term="SDL" scheme="https://huongvnq.github.io/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL SDL - Schema Definition Language Phần 2</title>
    <link href="https://huongvnq.github.io/2021/02/21/graphql-sdl-2/"/>
    <id>https://huongvnq.github.io/2021/02/21/graphql-sdl-2/</id>
    <published>2021-02-21T04:33:14.000Z</published>
    <updated>2021-07-23T04:39:43.912Z</updated>
    
    <content type="html"><![CDATA[<p>Nối tiếp Phần một về Schema Difinition Language của GraphQL, bài viết này trình bày tiếp các khái niệm được sử dụng để định nghĩa GraphQL Schema</p><h2 id="1-Interfaces"><a href="#1-Interfaces" class="headerlink" title="1. Interfaces"></a>1. Interfaces</h2><ul><li><p>Cũng giống như khái niệm <strong>Interface</strong> ở các language khác, trong GraphQL, một <strong>Interface</strong> là một <strong>asbstract type</strong> có thể bao gồm một tập nhất định các field mà các type khi <strong>implement</strong> nó cũng phải bao gồm các field đó.</p></li><li><p>Ví dụ, bạn có một interface <code>Character</code> đại diện cho bất kì nhân vật nào trong Star Wars</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bất kì type nào mà <strong>Implements</strong> <code>Characters</code> cần phải có đầy đủ các trường trên với cùng tham số hay cùng type.</p></li><li><p>Ví dụ, các type sau đây có thể implement <code>Character</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  starships: [Starship]</span><br><span class="line">  totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cả 3 type này đều có tất cả các trường từ <code>Character</code> interface, đồng thời cũng có các trường bổ sung như <code>totalCredits</code>, <code>starships</code>, <code>primaryFunction</code> giúp xác định các loại Character cụ thể.</p></li><li><p><strong>Interface</strong> hữu ích khi mà bạn muốn trả về một object hay là một bộ các object, nhưng chúng lại có các trường khác nhau.</p></li><li><p>Ví dụ, câu query sau sẽ sinh ra lỗi</p><p>QUERY DEFINITION</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  hero(episode: Episode): Character</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLIENT CALL QUERY</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VARIABLES</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;JEDI&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RESULT</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Cannot query field \&quot;primaryFunction\&quot; on type \&quot;Character\&quot;. Did you mean to use an inline fragment on \&quot;Droid\&quot;?&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;locations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>Trường <code>hero</code> trả về một kiểu <code>Character</code>, nó có thể là <code>Human</code> hay <code>Droid</code> tùy thuộc vào biến <code>episode</code>. Trong câu query trên bạn chỉ có thể chỉ định trả về những field mà tồn tại trong <code>Character</code> interface, như vậy sẽ không có <code>primaryFunction</code></li><li>Để yêu cầu trả về các trường trong một object type cụ thể, sử dụng <strong>inline fragments</strong><br><img src="/2021/02/21/graphql-sdl-2/inline-fragment.webp" alt="Inline Fragments"></li></ul><h2 id="2-Union-types"><a href="#2-Union-types" class="headerlink" title="2. Union types"></a>2. Union types</h2><ul><li><p>Ví dụ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union SearchResult = Human | Droid | Starship</span><br></pre></td></tr></table></figure></li><li><p>Bất cứ khi nào chúng ta trả về một loại <code>Search Result</code> trong schema, SearchResult này có thể là một <code>Human</code>, <code>Droid</code>, hoặc một <code>Starship</code>. Các thành phần của một <strong>union type</strong> cần phải là một loại đối tượng cụ thể, không được là một <strong>interface</strong> hay là một <strong>union</strong> khác</p></li><li><p>Khi phía client query một field mà trả về một union type là <code>SearchResult</code>, chúng ta cần phải sử dụng <strong>inline fragment</strong> để có thể query bất kì trường nào.</p><p>CLIENT QERRY</p></li></ul><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>RESULT<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;search&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;__typename&quot;</span>: <span class="string">&quot;Human&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;height&quot;</span>: <span class="number">1.8</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;__typename&quot;</span>: <span class="string">&quot;Human&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;height&quot;</span>: <span class="number">1.5</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;__typename&quot;</span>: <span class="string">&quot;Starship&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;TIE Advanced x1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;length&quot;</span>: <span class="number">9.2</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>Trường <strong>__typename</strong> là một <strong>String</strong> giúp bạn phân biệt sự khác nhau giữa các object type ở Client</li><li>Ở ví dụ này, vì <code>Human</code> và <code>Droid</code> cùng implement một interface chung là <code>Character</code> nên bạn có thể query những trường chung của 2 object type này ở chỉ một chỗ mà không cần lặp lại các trường giống nhau ở mỗi type, ví dụ sau đây cho kết quả như bên trên:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Character &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Lưu ý: Trường <code>name</code> vẫn phải được chỉ định đối với Starship bởi <code>Starship</code> không phải là một <code>Character</code></li></ul><h2 id="3-Input-types"><a href="#3-Input-types" class="headerlink" title="3.Input types"></a>3.Input types</h2><ul><li><p>Từ đầu đến giờ, chúng ta chỉ nói về truyền vào một field các argument thuộc về kiểu scalar như enums hay strings. Tuy nhiên bạn có thể truyền argument là một object phức tạp. Điều này cực kì hữu ích khi bạn muốn truyền vào toàn bộ object để tạo cái gì đó.</p></li><li><p>Trong GraphQL SDL, <strong>input types</strong> nhìn sẽ giống một <strong>object types</strong> thông tường nhưng với keyword <strong>input</strong> thay vì <strong>type</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input ReviewInput &#123;</span><br><span class="line">  stars: Int!</span><br><span class="line">  commentary: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Ví dụ sử dụng <strong>input type</strong> trong một <strong>mutation</strong></p><p>MUTATION DEFINITION</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VARIABLES</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;JEDI&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;review&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;stars&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;commentary&quot;</span>: <span class="string">&quot;This is a great movie!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RESULT</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;createReview&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;stars&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;commentary&quot;</span>: <span class="string">&quot;This is a great movie!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Ket-luan"><a href="#4-Ket-luan" class="headerlink" title="4. Kết luận"></a>4. Kết luận</h2><ul><li>Quan hai phần của chủ đề này, mình đã trình bày các khái niệm được sử dụng trong Schema Difinition Language. Mình tin là những khái niệm này đủ để bạn có thể tự định nghĩa một schema cơ bản của mình. Mong bài viết có ích đối với các bạn</li><li>Nguồn tham khảo<ul><li><a href="https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51">https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51</a></li><li><a href="https://graphql.org/learn/schema">https://graphql.org/learn/schema</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Nối tiếp Phần một về Schema Difinition Language của GraphQL, bài viết này trình bày tiếp các khái niệm được sử dụng để định nghĩa GraphQL</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="API" scheme="https://huongvnq.github.io/tags/API/"/>
    
    <category term="schema" scheme="https://huongvnq.github.io/tags/schema/"/>
    
    <category term="SDL" scheme="https://huongvnq.github.io/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL SDL - Schema Definition Language Phần 1</title>
    <link href="https://huongvnq.github.io/2021/02/21/graphql-sdl-1/"/>
    <id>https://huongvnq.github.io/2021/02/21/graphql-sdl-1/</id>
    <published>2021-02-21T04:29:05.000Z</published>
    <updated>2021-07-23T04:32:00.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-GraphQL-Schema-Difinition-Language-la-gi"><a href="#1-GraphQL-Schema-Difinition-Language-la-gi" class="headerlink" title="1. GraphQL Schema Difinition Language là gì?"></a>1. GraphQL Schema Difinition Language là gì?</h2><p><img src="/2021/02/21/graphql-sdl-1/graphql-sdl.png" alt="GraphQL SDL"></p><ul><li>Qua các bài viết trước trong series về <strong>GraphQL</strong>, chúng ta đã hiểu được các khái niệm GraphQL, Schema. GraphQL có một ngôn ngữ riêng để định nghĩa Schema đó là <strong>GraphQL Schema Definition Language</strong> (<strong>SDL</strong>)</li><li><strong>SDL</strong> là một ngôn ngữ có cú pháp rất đơn giản, dễ hiểu đồng thời cũng rất mạnh mẽ và trực quan giúp định nghĩa schema một các cô đọng nhất.</li><li>Ví dụ sử dụng SDL để định nghĩa Schema cho một ứng dụng blogging đơn giản<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Post &#123;</span><br><span class="line">  id: String!</span><br><span class="line">  title: String!</span><br><span class="line">  publishedAt: DateTime!</span><br><span class="line">  likes: Int! @default(value: 0)</span><br><span class="line">  blog: Blog @relation(name: &quot;Posts&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type Blog &#123;</span><br><span class="line">  id: String!</span><br><span class="line">  name: String!</span><br><span class="line">  description: String</span><br><span class="line">  posts: [Post!]! @relation(name: &quot;Posts&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Các thành phần chính của bản định nghĩa schema gồm có <strong>types</strong> và <strong>fields</strong>. Ngoài ra các thông tin bổ sung khác có thể được cung cấp là các <strong>custom directives</strong> như <strong>@default</strong> value được chỉ định cho trường <code>likes</code> hay <strong>@relation</strong> chỉ định mối quan hệ … Có rất nhiều thứ để nói ở đây, chúng ta hãy đi vào tìm hiểu chi tiết nhé.</li></ul><h2 id="2-Object-types-va-fields"><a href="#2-Object-types-va-fields" class="headerlink" title="2. Object types và fields"></a>2. Object types và fields</h2><ul><li>Phần tử cơ bản nhất của GrapQL Schema là <strong>object types</strong>, đại diện cho một loại đối tượng mà bạn có thể lấy được từ server.</li><li>Ví dụ<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Character</code> là một <strong>GraphQL Object Type</strong>, là một kiểu đối tượng với các trường (<strong>field</strong>). Hầu hết các <strong>type</strong> trong schema của bạn đều là các object types</li><li><code>name</code> và <code>appearsIn</code> là các <strong>field</strong> của <code>Character</code>. Điều này có nghĩa là <code>name</code> và <code>appearsIn</code> là các trường duy nhất được chỉ định khi truy vấn <code>Character</code></li><li>Một <strong>field</strong> thì gồm có name và type.</li><li><strong>String</strong> ở đây là type của field <code>name</code>, là một <strong>scalar type</strong> được xây dựng sẵn. Chúng ta sẽ đi vào tìm hiểu về <strong>scalar type</strong> ở bên dưới nhé.</li><li>Một <strong>field</strong> ngoài có kiểu <strong>scalar type</strong> thì có thể thuộc về bất kì kiểu nào tự định nghĩa trong schema.</li><li>Một <strong>field</strong> không thể null được biểu thị bằng dấu <strong>!</strong> , server bắt buộc phải trả về dữ liệu cho trường này khi bạn query.</li><li>Một <strong>field</strong> có kiểu là mảng được chỉ định bằng <strong>[]</strong>, ở đây <code>appearsIn</code> là một mảng các <code>Episode</code>.</li></ul><h2 id="3-Arguments"><a href="#3-Arguments" class="headerlink" title="3. Arguments"></a>3. Arguments</h2><ul><li>Mỗi một trường của một <strong>object type</strong> có thể không có hoặc có nhiều các đối số. VÍ dụ như trường <code>lenght</code> bên dưới:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  length(unit: LengthUnit = METER): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Không giống các ngôn ngữ lập trình khác như JavaScript hay Python, các function sẽ nhận các tham số theo thứ tự khi định nghĩa functon, trong GraphQL, các <strong>field</strong> sẽ nhận các tham số theo tên được truyền vào, thứ tự các tham số không ảnh hưởng. Trong ví dụ trên trường <code>length</code> có một tham số được định nghĩa là <code>unit</code></li><li>Một <strong>argument</strong> có thể required hoặc không. Khi một tham số là không required, chúng ta có thể định nghĩa default value cho nó, nếu tham số <code>unit</code> không được truyền vào, nó sẽ có giá trị default là <code>METER</code></li></ul><h2 id="4-Scalar-types"><a href="#4-Scalar-types" class="headerlink" title="4. Scalar types"></a>4. Scalar types</h2><ul><li><strong>Scalar type</strong> là kiểu cho một đối tượng vô hướng, có nghĩa là đối tượng này không có sub-selections (các trường con), chúng được coi là các lá của query.</li><li>Có 5 loại <strong>Scalar type</strong> được định nghĩa trong SDL<ul><li><strong>Int</strong>: Một số nguyên 32-bit không dấu</li><li><strong>Float</strong>: Một số thực dấu phẩy động</li><li><strong>String</strong>: Một chỗi UTF-8</li><li><strong>Boolean</strong>: true hoặc false</li><li><strong>ID</strong>: là một chuỗi định danh duy nhất, thường được sử dụng để lấy một object từ server</li></ul></li><li>Ngoài các kiểu <strong>scalar type</strong> được định sẵn, chúng ta có thể tự định nghĩa các <strong>custom scalar type</strong>. Ví dụ ta có thể định nghĩa một kiểu <code>Date</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar Date</span><br></pre></td></tr></table></figure>Đối với type Date chúng ta có thể validate hay format theo dạng Y/mm/dd, như vậy bất kì trường Date nào mà server trả về đều sẽ có dạng Y/mm/dd</li></ul><h2 id="5-Enumeration-types"><a href="#5-Enumeration-types" class="headerlink" title="5. Enumeration types"></a>5. Enumeration types</h2><ul><li><strong>Enums</strong> cũng là một kiểu đặc biệt của scalar type, được giới hạn trong một giá trị cho phép cụ thể, chúng ta có thể validate bất kì <strong>argument</strong> nào thuộc loại này chỉ có gía trị trong những giá trị cho phép.</li><li>Ví dụ<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Với bất kì field nào có kiểu <code>Episode</code> thì chỉ có thể là <code>NEWHOPE</code>, <code>EMPIRE</code>, hay <code>JEDI</code></li></ul><h2 id="6-Ket-phan-1"><a href="#6-Ket-phan-1" class="headerlink" title="6. Kết phần 1"></a>6. Kết phần 1</h2><ul><li>Trong bài viết này mình đã trình bày một số khái niệmcơ bản và hay sử dụng nhất khi định nghĩa một GraphQL Schema. Sang phần 2 mình sẽ trình bày các khái niệm phức tạp hơn nhưng cũng rất quan trọng và hữu ích</li><li>Nguồn tham khảo<ul><li><a href="https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51">https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51</a></li><li><a href="https://graphql.org/learn/schema/">https://graphql.org/learn/schema/</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-GraphQL-Schema-Difinition-Language-la-gi&quot;&gt;&lt;a href=&quot;#1-GraphQL-Schema-Difinition-Language-la-gi&quot; class=&quot;headerlink&quot; title=&quot;1. Graph</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="API" scheme="https://huongvnq.github.io/tags/API/"/>
    
    <category term="schema" scheme="https://huongvnq.github.io/tags/schema/"/>
    
    <category term="SDL" scheme="https://huongvnq.github.io/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>Cấu trúc cú pháp cơ bản của GraphQL</title>
    <link href="https://huongvnq.github.io/2020/10/18/graphql-core-concepts/"/>
    <id>https://huongvnq.github.io/2020/10/18/graphql-core-concepts/</id>
    <published>2020-10-18T04:23:59.000Z</published>
    <updated>2021-07-23T04:50:13.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Ngon-ngu-dinh-nghia-Schema-The-Schema-Definition-Language-SDL"><a href="#1-Ngon-ngu-dinh-nghia-Schema-The-Schema-Definition-Language-SDL" class="headerlink" title="1. Ngôn ngữ định nghĩa Schema - The Schema Definition Language (SDL)"></a>1. Ngôn ngữ định nghĩa Schema - The Schema Definition Language (SDL)</h2><ul><li>Như đã nói ở những bài viết trước về GraphQL, GraphQL sử dụng <strong>Schema</strong> như là một bản hợp đồng giữa Client và Server, một bản “quy chuẩn ngôn ngữ” giữa Client và Server, Client có thể dùng những cái định nghĩa trong Schema để gửi lên server lấy dữ liệu từ server và server cũng dựa vào đó để có thể biết mình làm gì và trả về kết quả gì cho Client.</li><li>GraphQL có một ngôn ngữ riêng để định nghĩa Schema. Đó là <strong>Schema Definition Language</strong> (<strong>SDL</strong>)</li><li>Ví dụ chúng ta có thể sử dụng <strong>SDL</strong> để định nghĩa một simple type <code>Person</code>:<br><code>php type Person &#123; name: String! age: Int! &#125;</code><br>type này có 2 trường, <code>name</code> và <code>age</code> tương ứng thuộc loại <strong>String</strong> và <strong>Int</strong>. Dấu <strong>!</strong> theo sau kiểu dữ liệu có nghĩa là trường này là <strong>required</strong></li><li>Chúng ta cũng có thể mô tả mối quan hệ (relationship) giữa 2 trường. Ví dụ về một ứng dụng blog, một <strong>Person</strong> có thể có nhiều bài <strong>Post</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Post &#123;</span><br><span class="line">  title: <span class="keyword">String</span>!</span><br><span class="line">  author: Person!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Ngược lại, ta khai báo type <strong>Person</strong> và đặt vào một chiều của mối quan hệ:<br><code>php type Person &#123; name: String! age: Int! posts: [Post!]! &#125;</code><br>Như bên trên, ta đã tạo một mối quan hệ <em>one-to-many</em> giữa <code>Person</code> và <code>Post</code> bởi trường <code>posts</code> trong type <code>Person</code> là một mảng các <code>Post</code>.</li><li>Khai báo mối quan hệ như này giúp cho Client có thể chỉ định các cấu trúc query lồng nhau, như vậy có thể lấy được toàn bộ dữ liệu mình cần chỉ trong một endpoint và không phải dùng nhiều endpoint như REST.</li><li>Để biết thêm về các cú pháp khác của SDL, tham khảo: <a href="https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51">https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51</a></li></ul><h2 id="2-Fetching-Data-voi-Queries"><a href="#2-Fetching-Data-voi-Queries" class="headerlink" title="2. Fetching Data với Queries."></a>2. Fetching Data với Queries.</h2><ul><li><p>Khi làm việc với REST APIs, dữ liệu được load từ những endpoint được chỉ định. Mỗi endpoint có một cấu trúc được định nghĩa rõ ràng về những thông tin mà nó trả về.</p></li><li><p>Đối với cách tiếp cận của GraphQL, thay vì có nhiều endpoints trả về dữ liệu cố định, GraphQL APIs chỉ dùng 1 endpoint và để cho người dùng có thể quyết định data thực sự cần để trả về. Do đó Client cần phải gửi nhiều thông tin hơn tới server để diễn tả yêu cầu về data, thông tin đó được gọi là <strong>query</strong></p></li><li><p>Ví dụ về một query mà client có thể gửi tới server</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>allPersons</code> được gọi là <strong>root field</strong> của query. Mọi thứ theo sau root field được gọi là <strong>payload</strong> của query. Ở đây chỉ có 1 field được chỉ định trong query payload là field <code>name</code></p></li><li><p>Câu query trên sẽ trả về danh sách tất cả các Person với tên của nó:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;allPersons&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Johnny&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Sarah&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mỗi một person chỉ có trường name trong response trả về, trường <code>age</code> không trả về vì nó không cần thiết đối với Client.</p><p>Nếu Client cũng cần trường <code>age</code>, tất cả những gì Client phải làm là điều chỉnh câu query và thêm trường vào payload.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Một trong những lợi thế lớn của GraphQL là nó cho phép truy vấn lồng nhau một cách tự nhiên. Ví dụ, bạn muốn load tất cả các bài <code>posts</code> của một <code>Person</code>, bạn có thể viết query như sau:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    posts &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server sẽ trả về response như sau:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   <span class="string">&quot;allPersons&quot;</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Binz&quot;</span>,</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>: [</span><br><span class="line">           &#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;GraphQL is awesome&quot;</span> &#125;,</span><br><span class="line">           &#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Relay is a powerful GraphQL Client&quot;</span>&#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Karik&quot;</span>,</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>: [</span><br><span class="line">            &#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Let&#x27;s get started with React &amp; GraphQL&quot;</span> &#125;,</span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Suboy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>: []</span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Queries với Arguments</strong>:<br>Trong GraphQL, mỗi field có thể có không hoặc nhiều tham số. Ví dụ, field <code>allPersons</code><br>có thể có tham số <code>last</code> để chỉ trả về một số lượng nhất định person.<br><code>&#123; allPersons(last: 2) &#123; name &#125; &#125;</code></p></li></ul><h3 id="3-Writing-Data-with-Mutations"><a href="#3-Writing-Data-with-Mutations" class="headerlink" title="3. Writing Data with Mutations."></a>3. Writing Data with Mutations.</h3><ul><li>Bên cạnh việc request data từ server, phía Client cũng cần phải making some changes tới data được lưu ở phía backend. Với GraphQL, ta có thể sử dụng <strong>mutations</strong> để làm điều đó. Nói chung, có 3 loại <strong>mutations</strong>:<ul><li>tạo mới data</li><li>cập nhật data đã tồn tại</li><li>Xóa data đã tồn tại.</li></ul></li><li><strong>Mutations</strong> tuân theo cấu trúc cú pháp giống như <strong>queries</strong>, tuy nhiên nó <em>luôn luôn phải bắt đầu với keyword</em> <strong>mutation</strong>. Ví dụ chúng ta tạo mới một <code>Person</code>:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  <span class="function"><span class="title">createPerson</span>(<span class="params">name: <span class="string">&quot;Sam&quot;</span>, age: <span class="number">23</span></span>)</span> &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Tương tự với query, mutation cũng có một <strong>root field</strong>, ở đây là <strong>createPerson</strong>. Ở đây field <code>createPerson</code> nhận vào 2 tham số là <code>name</code> và <code>age</code>.</li><li>Theo sau root field <code>createPerson</code> là <strong>payload</strong> cho mutation, ở đây là 2 trương <code>name</code> và <code>age</code>, là chỉ định dữ liệu trả về phía server. Với mutation trên, Server sẽ trả về response như sau:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;createPerson&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Realtime-Voi-Subscriptions"><a href="#4-Realtime-Voi-Subscriptions" class="headerlink" title="4. Realtime Với Subscriptions"></a>4. Realtime Với Subscriptions</h2><ul><li>Một yêu cầu đối với nhiều ứng dụng hiện nay là tính realtime với server, cho phép nhận được thông báo ngay lập tức về các sự kiện quan trọng. Đối với trường hợp này GraphQL cung cấp khái niệm <strong>subscriptions</strong>.</li><li>Khi một Client subscribes một event, một kết nối tới máy chủ sẽ được khởi tạo và giữ ổn định. Khi có một event cụ thể nào diễn ra, server sẽ đẩy dữ liệu tương ứng về cho client.</li><li>Nếu <strong>Queries</strong> và <strong>Mutations</strong> tuân theo “<strong>request-response-cycle</strong>“, <strong>subscriptions</strong> sẽ đại điện cho <strong>stream of data</strong> (dòng chảy dữ liệu) gửi tới client.</li><li>Ví dụ chúng ta subcribe một event:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  newPerson &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Sau khi client gửi subscription tới server, một kết nối đã được mở giữa client và server. Sau đó bất cứ khi nào <strong>mutation</strong> tạo mới Person được thực thi, server sẽ gửi thông tin về person này tới client:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;newPerson&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">23</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Dinh-nghia-Schema-cho-Queries-Mutations-va-Subscriptions"><a href="#5-Dinh-nghia-Schema-cho-Queries-Mutations-va-Subscriptions" class="headerlink" title="5. Định nghĩa Schema cho Queries, Mutations và Subscriptions."></a>5. Định nghĩa Schema cho Queries, Mutations và Subscriptions.</h2><ul><li><p>Để Client có thể sử dụng <strong>Queries</strong>, <strong>Mutations</strong> và <strong>Subscriptions</strong> như trên, chúng ta phải định nghĩa chúng ở <strong>Schema</strong>.</p></li><li><p>Nói tóm lại, một schema đơn giản là một tập hợp của các GraphQL type. Ngoài các type như Post, Person mà chúng ta ví dụ ở phần 1, chúng ta còn có các type đặc biệt như:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123; ... &#125;</span><br><span class="line">type Mutation &#123; ... &#125;</span><br><span class="line">type Subscription &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>Để Client có thể gọi được query <code>allPersons</code> như ở ví dụ bên trên, chúng ta phải định nghĩa chúng trong type Query:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  <span class="attr">allPersons</span>: [Person!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Tương tự với mutation <code>createPerson</code> và subscription <code>newPerson</code>, chúng ta sẽ có một tổng thể schema như sau:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  allPersons(last: Int): [Person!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createPerson(name: <span class="built_in">String</span>!, age: Int!): Person!</span><br><span class="line">  updatePerson(id: ID!, name: <span class="built_in">String</span>!, age: Int): Person!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Subscription &#123;</span><br><span class="line">  <span class="attr">newPerson</span>: Person!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person &#123;</span><br><span class="line">  <span class="attr">id</span>: ID!</span><br><span class="line">  name: <span class="built_in">String</span>!</span><br><span class="line">  age: Int!</span><br><span class="line">  posts: [Post!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  <span class="attr">id</span>: ID!</span><br><span class="line">  title: <span class="built_in">String</span>!</span><br><span class="line">  author: Person!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-Mot-chut-ve-Resolver"><a href="#6-Mot-chut-ve-Resolver" class="headerlink" title="6. Một chút về Resolver."></a>6. Một chút về Resolver.</h2><ul><li>Chúng ta đã có schema (như chúng ta đã biết, schema như một hợp đồng làm việc giữa client và server), chúng ta biết cách gọi các truy vấn (được định nghĩa ở schema) từ phía client. Vậy còn phía server, làm sao để từ file schema, server biết được mình sẽ xử lý như thế nào để trả về cho client.</li><li>Chúng ta sẽ có các hàm resolver. Ứng với mỗi <strong>field</strong> trong các type, sẽ có một resolver được định nghĩa để giải quyết yêu cầu phía client và trả về dữ liệu cho client. Các argument truyền vào các <strong>field</strong> cũng chính là những tham số được truyền vào resolvers.</li><li>Trên đây là khái quát về resolver, mình trình bày chi tiết về resolver trong bài viết lần sau.</li></ul><p>Nguồn tham khảo: <a href="https://www.howtographql.com/basics/2-core-concepts/">https://www.howtographql.com/basics/2-core-concepts/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Ngon-ngu-dinh-nghia-Schema-The-Schema-Definition-Language-SDL&quot;&gt;&lt;a href=&quot;#1-Ngon-ngu-dinh-nghia-Schema-The-Schema-Definition-Langua</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="API" scheme="https://huongvnq.github.io/tags/API/"/>
    
    <category term="schema" scheme="https://huongvnq.github.io/tags/schema/"/>
    
  </entry>
  
  <entry>
    <title>So sánh GrapQL với REST</title>
    <link href="https://huongvnq.github.io/2020/10/18/graphql-vs-rest/"/>
    <id>https://huongvnq.github.io/2020/10/18/graphql-vs-rest/</id>
    <published>2020-10-18T03:57:28.000Z</published>
    <updated>2021-07-21T04:10:31.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Gioi-thieu-chung"><a href="#1-Gioi-thieu-chung" class="headerlink" title="1. Giới thiệu chung"></a>1. Giới thiệu chung</h1><p><img src="/2020/10/18/graphql-vs-rest/graphql-vs-rest.png" alt="GraphQL Vs Rest"></p><ul><li>Trải qua nhiều thập kỉ, REST đã trở thành một tiêu chuẩn cho thiết kế Web API. REST có những ý tưởng rất tuyệt vời như là <strong>stateless servers</strong> hay là <strong>structured access to resources</strong>.</li><li>Tuy nhiên REST APIs vẫn còn chưa linh hoạt để bắt kịp với những yêu cầu thay đổi nhanh chóng phía client.</li><li>GraphQL được phát triển để đáp ứng nhu cầu linh hoạt hơn và hiệu quả hơn. Nó giải quyết nhiều những thiếu sót và kém hiệu quả mà developer đã trải nghiệm được sau một thời gian làm việc với REST API.</li><li>Ở bài viết lần trước mình cũng đã chia sẻ qua về GraphQL là gì, bài viết này mình sẽ đặt nó bên cạnh REST để làm nổi bật lên những ưu điểm vượt trội hơn so với REST.</li></ul><h1 id="2-Uu-diem-cua-GraphQL-so-voi-REST"><a href="#2-Uu-diem-cua-GraphQL-so-voi-REST" class="headerlink" title="2. Ưu điểm của GraphQL so với REST"></a>2. Ưu điểm của GraphQL so với REST</h1><table><thead><tr><th></th><th>REST</th><th>GraphQL</th></tr></thead><tbody><tr><td><strong>Data Fetching</strong></td><td>Nhiều Endpoint</td><td>1 Endpoint</td></tr><tr><td></td><td>Imperative data fetching</td><td>Declarative Data Fetching</td></tr><tr><td></td><td>Tồn tại Over Fetching và UnderFetching</td><td>Giải quyết OverFetching và UnderFetching</td></tr><tr><td><strong>Khi yêu cầu Client thay đổ</strong>i</td><td>Phải Thay đổi phía server</td><td>Có thể chỉ Phải Thay đổi phía Client</td></tr><tr><td><strong>Độ phụ thuộc giữa Backend và Frontend</strong></td><td>Không thể làm việc độc lập</td><td>Có thể làm việc độc lập</td></tr><tr><td><strong>Phân tích sự dư thừa dữ liệu</strong></td><td>Không thể phân tích được sự dư thừa dữ liệu</td><td>Có thể phân tích được sự dư thừa dữ liệu và hiệu suất của ứng dụng.</td></tr></tbody></table><h2 id="2-1-Data-Fetching-voi-GraphQL-va-REST"><a href="#2-1-Data-Fetching-voi-GraphQL-va-REST" class="headerlink" title="2.1 Data Fetching với GraphQL và REST"></a>2.1 Data Fetching với GraphQL và REST</h2><p>Để làm rõ sự khác nhau giữa REST và GraphQL khi fetching data từ API, chúng ta hãy xem xét một kịch bản đơn giản sau: Với một ứng dụng blog, ứng dụng sẽ cần hiển thị list tiêu đề các bài post của một user cụ thể. Cùng màn hình đó, bạn cũng cần phải hiển thị tên của 3 followers của user đó. Hãy cùng xem cách mà REST và GraphQL xử lý.</p><h3 id="2-1-1-Multiple-Endpoint-va-Single-Endpoint"><a href="#2-1-1-Multiple-Endpoint-va-Single-Endpoint" class="headerlink" title="2.1.1 Multiple Endpoint và Single Endpoint"></a>2.1.1 Multiple Endpoint và Single Endpoint</h3><ul><li><strong>Với REST API</strong>, bạn sẽ lấy data bằng việc sử dụng nhiều endpoint. Với kịch bản trên, Bạn sẽ sử dụng 1 endpoint /users/{id} để lấy dữ liệu của user. Sau đó bạn sẽ sử dụng 1 endpoint nữa là /user/{id}/posts để lấy tất cả các bài post của user. Endpoint thứ ba sẽ là /user/{id}/followers trả về danh sách các follower của user.</li></ul><p><img src="/2020/10/18/graphql-vs-rest/multi-endpoint.png" alt="Multiple Endpoint"></p><ul><li><strong>Với GraphQL</strong>, bạn chỉ cần đơn giản gửi một câu query tới GraphQL Server bao gồm các yêu cầu dữ liệu cụ thể. Server sẽ trả về một JSON object đáp ứng các yêu cầu client gửi lên. Chú ý rằng Cấu trúc response mà Server trả về sẽ tuân theo chính xác cấu trúc lồng nhau mà được chỉ định trong query gửi lên từ Client.</li></ul><p><img src="/2020/10/18/graphql-vs-rest/single-endpoint.png" alt="Single Endpoint"></p><h3 id="2-1-2-GraphQL-giai-quyet-Overfetching-va-Underfetching"><a href="#2-1-2-GraphQL-giai-quyet-Overfetching-va-Underfetching" class="headerlink" title="2.1.2 GraphQL giải quyết Overfetching và Underfetching"></a>2.1.2 GraphQL giải quyết Overfetching và Underfetching</h3><p>Một vấn đề thông thường nhất gặp phải với REST là Overfetching và Underfetching. Điều này xảy ra do Client sử dụng endpoint để lấy dữ liệu về, và các endpoint thì trả về cấu trúc dữ liệu cố định. Điều này dẫn đến những khó khăn cho việc thiết kế API làm thế nào để có thể cung cấp cho client chính xác những gì mà client cần.</p><ul><li><p><strong>Overfetching</strong>: Trả về dư thừa dữ liệu cho Client</p><p>Overfetching có nghĩa là một Client lấy được nhiều thông tin hơn so với những gì nó cần. Ví dụ dễ hiểu một màn hình cần hiển thị danh sách các user chỉ với tên của các user đó. Nhưng với REST API, bạn gọi endpoint <strong>/users</strong> và nhận về mảng JSON các dữ liệu của user. Response có thể chứa nhiều thông tin của user như ngày sinh, địa chỉ của user…, những thông này vô dụng với client vì client chỉ cần hiển thị tên của các user.</p></li><li><p><strong>Underfetching</strong> và vấn đề <strong>n+1</strong></p><p>Underfetching có nghĩa là một endpoint cụ thể không cung cấp đủ thông tin yêu cầu cho client. Client phải thực hiện thêm những request khác để lấy thêm dữ liệu mà nó cần. Khi đó vấn đề <strong>n+1</strong> xảy ra khi mà đầu tiên Client cần lấy về một list các phần tử, nhưng sau đó đối với mỗi phần tử lại phải tạo một request để lấy dữ liệu yêu cầu của mỗi phần tử!</p><p>Ví dụ với kịch bản ứng dụng cần hiển thị list user, và mỗi user cần hiển thị 3 followers gần nhất. Đầu tiên ứng dụng cần phải gọi 1 endpoint <strong>/users</strong> và sau đó ứng với mỗi user, chúng ta phải thực hiện một endpoint bổ sung là <strong>/users/<user-id>/followers</strong></p></li></ul><p>Với việc sử dụng 1 endpoint, cho phép client chỉ định những dữ liệu nào mà client cần, server trả về đúng dữ liệu theo cấu trúc lồng nhau được chỉ định trong query của client thì GraphQL đã giải quyết được vấn đề Overfetching và Underfetching.</p><h3 id="2-1-3-Imperative-data-fetching-va-Declarative-Data-Fetching"><a href="#2-1-3-Imperative-data-fetching-va-Declarative-Data-Fetching" class="headerlink" title="2.1.3 Imperative data fetching và Declarative Data Fetching"></a>2.1.3 Imperative data fetching và Declarative Data Fetching</h3><ul><li><p>REST theo phương pháp <strong>Imperative data fetching</strong> (Tìm nạp dữ liệu mệnh lệnh). Khi fetching data từ REST API, một ứng dụng cần phải thực hiện các bước sau:</p><ol><li>Gửi dữ liệu HTTP request (vd fetch trong javascript)</li><li>Nhận và parse dữ liệu nhận được từ server.</li><li>Store dữ liệu dưới local.</li><li>Hiển thị dữ liệu trên UI</li></ol></li><li><p>GraphQL tiếp cận theo ý tưởng <strong>declarative data fetching</strong> (Tìm nạp dữ liệu khai báo), Client chỉ việc thực hiện 2 bước sau:</p><ol><li>Mô tả yêu cầu dữ liệu.</li><li>Hiển thị dữ liệu trên UI.</li></ol><p>Cách tiếp cận này tập trung vào việc Client sẽ khai báo dữ liệu (declarative data), còn trừu tượng hóa các tác vụ khác cũng như việc lưu trữ dữ liệu.</p></li></ul><h2 id="2-2-Van-de-dap-ung-su-thay-doi-nhanh-chong-phia-Client"><a href="#2-2-Van-de-dap-ung-su-thay-doi-nhanh-chong-phia-Client" class="headerlink" title="2.2 Vấn đề đáp ứng sự thay đổi nhanh chóng phía Client."></a>2.2 Vấn đề đáp ứng sự thay đổi nhanh chóng phía Client.</h2><ul><li>Với REST API, Client sẽ gọi các endpoint tương ứng cho các view, server sẽ trả về tất cả các thông tin được yêu cầu cho một view cụ thể. Tuy nhiên điểm yếu của REST API ở chỗ này là nó sẽ không đáp ứng nhanh chóng sự thay đổi phía Client. Với mỗi sự thay đổi phía UI (chẳng hạn như yêu cầu nhiều dữ liệu hơn), thì phía backend (server) cũng phải thay đổi để đáp ứng yêu cầu dữ liệu mới. Nó sẽ làm giảm hiệu suất, và chậm việc update product liên tục.</li><li>Với GraphQL, vấn đề này đã được giải quyết. Nhờ có sự linh hoạt phía GraphQL, sự thay đổi phía Client sẽ không dẫn đến phải thay đổi phía server, bởi client có thể chỉ định chính xác yêu cầu dữ liệu mà client cần, do đó chỉ việc thay đổi phía Client.</li></ul><h2 id="2-3-Do-phu-thuoc-giua-Backend-va-Frontend-Loi-the-cua-Schema-va-Type-cua-GraphQL"><a href="#2-3-Do-phu-thuoc-giua-Backend-va-Frontend-Loi-the-cua-Schema-va-Type-cua-GraphQL" class="headerlink" title="2.3 Độ phụ thuộc giữa Backend và Frontend - Lợi thế của Schema và Type của GraphQL"></a>2.3 Độ phụ thuộc giữa Backend và Frontend - Lợi thế của Schema và Type của GraphQL</h2><ul><li>GraphQL sử dụng hệ thống Type và sử dụng Schema Definition Language (SDL) để định nghĩa Schema. Hãy hiểu Schema như là một hợp đồng giữa Client và Server, một bản mô tả cách mà client có thể lấy dữ liệu trên Server.</li><li>Một khi Schema đã được định nghĩa, team frontend và team backend có thể làm việc độc lập và không cần trao đổi với nhau nhiều vì cả 2 bên đã biết được cấu trúc dữ liệu sẽ được transfer như nào.</li><li>Team Frontend có thể tạo dummy test data để test ứng dụng và khi server đã sẵn sàng, team frontend sẽ chuyển sang lấy dữ liệu từ API thực tế. Điều này giúp tăng hiệu suất làm việc rất nhiều.</li></ul><h2 id="2-4-Phan-tich-su-du-thua-du-lieu"><a href="#2-4-Phan-tich-su-du-thua-du-lieu" class="headerlink" title="2.4 Phân tích sự dư thừa dữ liệu"></a>2.4 Phân tích sự dư thừa dữ liệu</h2><ul><li>Với REST API, chúng ta có toàn bộ dữ liệu được trả về trong một API endpoint, như vậy chúng ta sẽ không biết được thông tin về việc sử dụng các trường dữ liệu cụ thể.</li><li>Đối với GraphQL, chúng ta sẽ chỉ định chính xác những gì chúng ta cần, như vậy chúng ta sẽ biết được trường dữ liệu nào đang được sử dụng và trường dữ liệu nào không được request từ Client nữa.</li><li>Hơn nữa, GraphQL sử dụng resolver function để xử lý dữ liệu mà client yêu cầu. Các phương pháp đo lường hiệu suất cho các resolvers sẽ giúp bạn nhìn thấy được những chỗ “cổ chai” trong ứng dụng của bạn, giúp bạn có thể theo dõi được performance của hệ thống.</li></ul><h1 id="3-Nhuoc-diem-cua-GraphQL"><a href="#3-Nhuoc-diem-cua-GraphQL" class="headerlink" title="3. Nhược điểm của GraphQL"></a>3. Nhược điểm của GraphQL</h1><ul><li>GraphQL luôn trả về HTTP status code là 200, bất kể query có success hay không. Nếu query fail, JSON response trả về sẽ có key <strong>errors</strong>, với các error message và stacktrace. Điều này gây khó khăn hơn trong việc error handling.</li><li>Phải thiết kế Schema trước, sẽ vất vả hơn vì thêm việc mặc dù sau này schema sẽ giúp bạn ngăn chặn nhiều lỗi và đỡ tốn sức hơn khi nâng cấp.</li><li>Khi Client không cần quan tâm đến data lấy từ đâu thì Sự phức tạp được đẩy về phía server, GraphQL không phải là giải pháp tốt cho các ứng dụng đơn giản.</li><li>Vấn đề caching. REST API sử dụng nhiều endpoint nên nó tận dùng HTTP caching để tránh việc phải tìm nạp lại tài nguyên. Với GraphQL, nó sử dụng 1endpoint thay vì theo cơ chế caching của HTTP. Lưu vào bộ nhớ đệm là rất quan trọng vì nó làm giảm sự truy cập vào máy chủ. Với GraphQL, bạn phải sử dụng thư viện khác phía Client để đáp ứng việc caching.</li></ul><h1 id="4-Ket-luan"><a href="#4-Ket-luan" class="headerlink" title="4. Kết luận"></a>4. Kết luận</h1><ul><li>Bài viết trên mình đã trình bày sự khác nhau giữa REST và GraphQL qua những ưu nhược điểm của GraphQL so với REST. Cả REST và GraphQL đều là những cách nổi bật để thiết kế API. REST đơn giản hóa đáng kể công việc của dev với cách tiếp cận tiêu chuẩn, tuy nhiên nó cũng có vài nhược điểm. GraphQL giải quyết những nhược điểm của REST và có nhiều ưu điểm vượt trội hơn so với REST, tuy nhiên không phải lúc nào nó cũng là giải pháp tốt nhất. Đối với những ứng dụng xử lý dữ liệu tương đối nhất quán, mình nghĩ nên sử dụng REST API. Còn đối với những ứng dụng mà cần xử lý với dữ liệu thay đổi nhanh chóng, yêu cầu update product liên tục thì hãy trải nghiệm với GraphQL.</li><li>Anyway, bạn có thể sử dụng cả REST và GraphQL trong 1 project. Hãy phân tích ứng dụng của bạn và yêu cầu hiệu suất để có lựa chọn thích hợp nhé. Hẹn gặp lại các bạn trong các bài viết tiếp theo của Series GraphQL.</li><li>Nguồn tham khảo: <a href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/">https://www.howtographql.com/basics/1-graphql-is-the-better-rest/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Gioi-thieu-chung&quot;&gt;&lt;a href=&quot;#1-Gioi-thieu-chung&quot; class=&quot;headerlink&quot; title=&quot;1. Giới thiệu chung&quot;&gt;&lt;/a&gt;1. Giới thiệu chung&lt;/h1&gt;&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="REST API" scheme="https://huongvnq.github.io/tags/REST-API/"/>
    
    <category term="API" scheme="https://huongvnq.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Giới thiệu chung về GraphQL</title>
    <link href="https://huongvnq.github.io/2020/10/18/introduction-graphql/"/>
    <id>https://huongvnq.github.io/2020/10/18/introduction-graphql/</id>
    <published>2020-10-18T03:00:58.000Z</published>
    <updated>2021-07-21T03:33:49.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Nhac-lai-ve-REST"><a href="#1-Nhac-lai-ve-REST" class="headerlink" title="1. Nhắc lại về REST"></a>1. Nhắc lại về REST</h1><ul><li>REST (<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer): được sáng lập bởi người sáng lập ra phương thức HTTP.</li><li>Là một tiêu chuẩn để viết API, sử dụng phương thức HTTP đơn giản để giao tiếp giữa các máy.</li><li>REST gửi một yêu cầu HTTP như GET, POST, UPDATE, DELETE đến một URL để xử lý dữ liệu<br><img src="/2020/10/18/introduction-graphql/rest-handle-request.jpeg" alt="Rest Handle Request"></li></ul><ul><li>REST mang lại rất nhiều ưu điểm (ứng dụng rõ ràng, code dễ dàng đơn giản hơn, dữ liêu trả về dưới nhiều định dạng…). Ttrải qua rất nhiều năm, REST là cách phổ biến nhất để client giao tiếp server. REST cũng là giải pháp phù hợp với rất nhiều ứng dụng đặc biệt là các ứng dụng đơn giản, tốc độ phát triển chậm.</li><li>Tuy nhiên ngày nay, nhiều ứng dụng lại có tốc độ phát triển nhanh, thay đổi cập nhật liên tục, dẫn đến các API cũng phải thay đổi dữ liêu trả về tương ứng… Điều này dẫn đến ra đời <strong>GraphQL</strong></li></ul><h1 id="2-GraphQL-la-gi"><a href="#2-GraphQL-la-gi" class="headerlink" title="2. GraphQL là gì?"></a>2. GraphQL là gì?</h1><ul><li>Là một tiêu chuẩn API mới cung cấp một giải pháp thay thế hiệu quả, mạnh mẽ, linh hoạt hơn so với REST.</li><li>Cho phép Client có thể chỉ định chính xác những data nào mà Client thật sự cần từ một API.</li><li>Thay vì multiple endpoints trả về cấu trúc data cố định, GraphQL chỉ sử dụng Một endpoint, và trả về chính xác dữ liệu mà client yêu cầu.</li><li>GraphQL thường bị nhầm tưởng là một công nghệ Database. Điều đó là quan niệm sai lầm. GraphQL là một <strong>query language cho API</strong>, không phải cho database. Điều đó có nghĩa là chúng ta có thể sử dụng GraphQL mà không cần quan tâm database là gì.</li></ul><h1 id="3-Tai-sao-lai-phat-trien-GraphQL"><a href="#3-Tai-sao-lai-phat-trien-GraphQL" class="headerlink" title="3. Tại sao lại phát triển GraphQL"></a>3. Tại sao lại phát triển GraphQL</h1><ul><li>Sự ra tăng của các việc sử dụng các thiết bị mobile, nhiều thiết bị mobile công suất thấp, mạng yếu, đòi hỏi cần phải load dữ liệu một cách hiệu quả.<br>Đây là lý do Facebook sáng chế ra GraphQL. GraphQL giảm thiểu số lượng data transfer qua mạng.</li><li>Có nhiều các framework và platform frontend khác nhau.<br>Gây khó khăn cho việc xây dựng và bảo trì <strong>một API</strong> mà đáp ứng yêu cầu của <strong>các</strong> framework và platform. Với GraphQL, mỗi client có thể truy cập chính xác đc dữ liệu nó cần.</li><li>Đáp ứng sự triển khai nhanh chóng liên tục và cập nhật product thường xuyên.<br>Với Rest API, phía máy chủ cần được sửa đổi để giải quyết các yêu cầu cụ thể và thay đổi design phía clients. Điều này cản trở yêu cầu triển khai nhanh chóng và liên tục.</li></ul><h1 id="4-Cau-chuyen-ve-GraphQL"><a href="#4-Cau-chuyen-ve-GraphQL" class="headerlink" title="4. Câu chuyện về GraphQL"></a>4. Câu chuyện về GraphQL</h1><ul><li>GraphQL được sáng chế bởi Facebook. Facebook bắt đầu sử dụng GraphQL vào năm 2012 trong các ứng dụng mobile native của họ.</li><li>Lần đầu tiên Facebook phát ngôn chính thức về nó là ở React.js Conf 2015 và ngay sau đó họ đã open source nó.</li><li>Tại vì Facebook luôn nói về GraphQL trong bối cảnh của ReactJS nên tại thời điểm đó nhiều người chỉ nghĩ rằng GraphQL chỉ giới hạn sử dụng cho React, nhưng không phải vậy, thực tế GraphQL là một công nghệ mà có thể sử dụng <strong>mọi nơi Client giao tiếp với API.</strong></li></ul><p><img src="react-graphql-conf.png" alt="React Conf"    title="React Conf" width="700px" hight="auto"/></p><ul><li><p>GraphQL có một cộng đồng phát triển nhanh chóng:</p><p>Trước khi Facebook công bố GraphQL, thì các công ty khác như <strong>Netflix</strong> hay <strong>Coursera</strong> cũng đang phát triển những ý tưởng tương đồng với mục đích làm cho tương tác với API hiệu quả hơn. Coursera cũng đã hình dung ra một công nghệ tương tự cho phép client chỉ định những yêu cầu về dữ liệu trả về. Còn Netflix thì thậm chí cũng đã open-source giải pháp của họ gọi là <strong><a href="https://github.com/Netflix/falcor">Falcor</a></strong>.</p><p>Tuy nhiên sau khi GraphQL đc open-source, Coursera đã từ bỏ nỗ lực của họ và nhảy sang dùng GraphQL.</p></li><li><p>Ngày nay GraphQL được sử dụng bởi nhiều công ty khác nhau như GitHub, Twitter, Shopify, Yelp…</p></li></ul><p><img src="community2.png" alt="Community"    title="Community" width="700px" hight="auto"/></p><h1 id="5-Ket-luan"><a href="#5-Ket-luan" class="headerlink" title="5. Kết luận"></a>5. Kết luận</h1><ul><li>Bài viết này mình đã giới thiệu chung về GraphQL, với mong muốn mọi người hiểu được GraphQL là gì, Tại sao nó lại ra đời. Mình cũng muốn nhấn mạnh là GraphQL là <strong>một query language cho API</strong>, nó ra đời để khắc phục những thiếu sót và nhược điểm của REST.</li><li>Bài viết sau mình sẽ đi vào so sánh GraphQL và REST để làm rõ hơn sự khác nhau giữa GraphQL và REST cũng như những ưu điểm của GraphQL.</li><li>Nguồn tham khảo: <a href="https://www.howtographql.com/basics/0-introduction/">https://www.howtographql.com/basics/0-introduction/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Nhac-lai-ve-REST&quot;&gt;&lt;a href=&quot;#1-Nhac-lai-ve-REST&quot; class=&quot;headerlink&quot; title=&quot;1. Nhắc lại về REST&quot;&gt;&lt;/a&gt;1. Nhắc lại về REST&lt;/h1&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://huongvnq.github.io/categories/GraphQL/"/>
    
    
    <category term="graphql" scheme="https://huongvnq.github.io/tags/graphql/"/>
    
    <category term="API" scheme="https://huongvnq.github.io/tags/API/"/>
    
    <category term="Facebook Graph API" scheme="https://huongvnq.github.io/tags/Facebook-Graph-API/"/>
    
  </entry>
  
</feed>
